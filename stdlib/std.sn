import std::internal::preload;
import std::c_bindings;
import std::ptr;

type usize = u64; // TODO: make this 32 bit dependent on the target

/**
 * @typedef String
 * @brief A type alias for a generic string type.
 *
 * The `String` type alias is used to define a generic string type based on the `StringView` class.
 * This allows you to work with strings in a more flexible and abstract manner. You can use the `String`
 * type for various string manipulation operations and seamlessly switch between different string implementations.
 *
 * @see StringView
 */
public type String = StringView<>;
/**
 * @interface ToString
 * @brief An interface for objects that can be converted to a string representation.
 *
 * The `ToString` interface defines a contract for objects that can be converted to a string
 * representation. Classes implementing this interface must provide the `to_string` method,
 * which returns a string representation of the object.
 */
public interface ToString {
  public:
    /**
     * @brief Converts the object to a string representation.
     * @return A string representation of the object.
     */
    func to_string() String;
};
/**
 * @interface Clone
 * @brief An interface for objects that can be cloned.
 *
 * The `Clone` interface defines a contract for objects that can be cloned. Classes implementing
 * this interface must provide the `clone` method, which returns a clone of the object.
 *
 * @tparam T The type of the object to clone.
 */
public interface Clone<T> {
  public:
    /**
     * @brief Clones the object.
     * @return A clone of the object.
     */
    func clone() T;
};
/**
 * @interface Debug
 * @brief An interface for objects that provide debugging information as a string.
 *
 * The `Debug` interface defines a contract for objects that can provide debugging information
 * as a string. Classes implementing this interface must provide the `debug` method, which
 * returns a string containing debugging details about the object.
 */
public interface Debug {
  public:
    /**
     * @brief Provides debugging information about the object.
     * @return A string containing debugging details.
     */
    func debug() String;
};
/**
 * @interface Throwable
 * @brief An interface for objects that can be thrown as exceptions.
 * 
 * The `Throwable` interface defines a contract for objects that can be thrown as exceptions.
 * Classes implementing this interface must provide the `throw` method, which throws the object
 * as an exception.
 */
public interface Throwable { }
/**
 * @class Exception
 * @brief A class representing an exception.
 *
 * The Exception class provides various operations and functionalities
 * for working with exceptions. It supports common Exception
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
public class Exception implements ToString, Throwable {
  public:
    /**
     * @brief Exception constructor.
     * @param[in] m The message of the exception.
     */ 
    Exception(m: String) : msg(m.bytes()), length(m.size())
      { /* Nothing to do here ðŸ‘‹ */ }
    /**
     * @brief Returns the message of the exception.
     * @return The message of the exception.
     */
    @inline
    func what() String { 
      // Return a string from the message and its length.
      // We store the message as a char pointer and its length
      // so we can easily fetch the message from the C side without
      // having to keep track of snowball's string implementation.
      // This is a bit hacky, but it works. ðŸ˜Š
      return String::from(self.msg, self.length); 
    }
    /**
     * @brief Returns a string representation of the exception.
     * @return A string representation of the exception.
     */
    func to_string() String { return self.what(); }
  private:
    /** The message of the exception. */
    let msg: String::StringType;
    /** The message length */
    let length: i32;
}
/**
 * @class IndexError
 * @brief A class representing an index error.
 *
 * The IndexError class provides various operations and functionalities
 * for working with index errors. It supports common IndexError
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
public class IndexError extends Exception 
  { /* Nothing to do here ðŸ‘‹ */ }
/**
 * @interface Iterable
 * @brief An interface representing an iterable.
 *
 * The `Iterable` interface defines a contract for objects that can be iterated over. It provides
 * various operations and functionalities for working with iterables, allowing you to access
 * elements, iterate through collections, and reset the iteration state if needed.
 *
 * @typeparam IterType The type of elements in the iterable.
 *
 * @remarks
 * This interface is designed to be implemented by classes that represent iterable data structures.
 * Implementing classes should provide the `next` method to advance the iterator and the `reset` method
 * to reset the iteration to the beginning if necessary.
 */
public interface Iterable<IterType: Sized> {
    /// @brief The index of the iterator.
    let mut iter_index: i32 = 0;
  public:
    /**
     * @brief Advances the iterator to the next element.
     *
     * The `next` method is used to advance the iterator to the next element in the iterable.
     * It should return the next element as an `Iter<IterType>`.
     *
     * @return The next element in the iterable.
     */
    virtual func next() Iter<IterType>;
    /**
     * @brief Resets the iterator to the beginning of the iterable.
     *
     * The `reset` method is used to reset the iterator's position to the 
     * beginning of the iterable. This can be useful when you need to reiterate 
     * over the collection.
     */
    virtual mut func reset() { self.iter_index = 0; }
}
/**
 * @class Iter
 * @brief A class representing an iterator.
 *
 * The `Iter` class serves as a general-purpose iterator that can be used to traverse collections.
 * It provides various operations and functionalities for working with iterators, allowing you to
 * access elements, determine iterator validity, and retrieve the iterator's value.
 *
 * @tparam T The type of elements that the iterator iterates over.
 *
 * @remarks
 * The `Iter` class can be considered as the reverse of the `Iterable` class and is typically used
 * to traverse and manipulate data structures that implement the `Iterable` interface. It offers
 * methods to retrieve the value of the iterator and check its validity.
 */
public class Iter<T: Sized> {
    /// @brief Indicates if the iterator is valid.
    let valid: bool = false;
    /// @brief Stores the value of the iterator.
    let iter_value: T = zero_initialized!(:T);
  public:
    /**
     * @brief Default constructor for `Iter`.
     *
     * This constructor creates an invalid iterator. Use it when you want to create an iterator without
     * specifying an initial value.
     */
    Iter() { /* Nothing to do here ðŸ‘‹ */ }
    /**
     * @brief Constructor for `Iter` with an initial value.
     *
     * This constructor initializes the iterator with a specified value and marks it as valid. It is
     * typically used to create a valid iterator.
     *
     * @param[in] value The initial value of the iterator.
     */
    Iter(value: T) : iter_value(value), valid(true) 
      { /* Still nothing to do here ðŸ˜Š */ }
    /**
     * @brief Returns the value of the iterator.
     * @return The value of the iterator.
     * @throws IndexError if the iterator is invalid.
     */
    @inline
    func value() T {
      // If the iterator is invalid, throw an IndexError.
      // This is useful when you want to access the value of the iterator
      // without checking its validity first.
      if !self.valid {
        // TODO: Add a better error message
        throw new IndexError("Invalid iterator access!");
      }
      // Otherwise, return the value of the iterator.
      return self.iter_value; 
    }
    /**
     * @brief Checks if the iterator is valid.
     * @return `true` if the iterator is valid, `false` otherwise.
     */
    @inline
    func is_valid() bool { return self.valid; }
  public:
    /**
     * @brief Returns an invalid iterator.
     * @return An invalid iterator with no initial value.
     */
    @inline
    static func invalid() Iter<T> { return new Iter<T>(); }
    /**
     * @brief Returns a valid iterator with an initial value.
     * @param[in] val The initial value of the iterator.
     * @return A valid iterator with the specified initial value.
     */
    @inline
    static func valid(val: T) Iter<T> { return new Iter<T>(val); }
}
/**
 * @class Range 
 * @brief A class representing a range of elements.
 *
 * The `Range` class provides a versatile mechanism for working with ranges of elements,
 * such as numerical values. It facilitates common range manipulation operations, including
 * iteration, element access, and range size calculation.
 *
 * @typeparam _Number_Type The type of elements within the range, which must be numeric.
 *
 * @implements Iterable<_Number_Type>
 *
 * @remarks
 * The `Range` class is designed for representing and manipulating ranges of elements. It can
 * be used for various purposes, including numerical iteration and subsetting. It implements the
 * `Iterable` interface, making it iterable and compatible with iteration-related utilities.
 */
public class Range<N: Numeric = i32> implements Iterable<N>, ToString {
  public:
    /**
     * @brief Constructor for `Range` with specified start and end values.
     *
     * @param[in] start The start of the range (inclusive).
     * @param[in] end The end of the range (exclusive).
     */
    Range(start: N, end: N) : start(start), end(end) {
      // Reset the iteration to the beginning of the range.
      // In this case, just set the iterator index to the start of the range.
      self.reset();
    }
    /**
     * @brief Constructor for `Range` with a default start value of 0.
     * @param[in] end The end of the range (exclusive).
     */
    Range(end: N) : end(end) { /* Nothing to do here ðŸ‘‹ */ }
    /**
     * @brief Returns the size of the range.
     * @return The size of the range.
     */
    @inline
    func size() N { return self.end - self.start; }
    /**
     * @brief Returns the start of the range.
     * @return The start of the range.
     */
    @inline
    func begin() N { return self.start; }
    /**
     * @brief Returns the end of the range.
     * @return The end of the range.
     */
    @inline
    func stop() N { return self.end; }
    /**
     * @brief Returns the next element in the iteration.
     * @return The next element in the iteration.
     */
    virtual mut func next() Iter<N> {
      // Increment the iterator index.
      self.iter_index = self.iter_index + 1;
      // If the iterator index is greater than or equal to the end of the range,
      // return an invalid iterator.
      if self.iter_index >= self.end {
        return Iter<?N>::invalid();
      }
      // Otherwise, return a valid iterator with the current iterator index.
      return Iter<?N>::valid(self.iter_index);
    }
    /**
     * @brief Resets the iteration to the beginning of the range.
     */
    @inline
    virtual mut func reset() { self.iter_index = self.start - 1; }
    /**
     * @brief Adds a value to the range with another range.
     * @param[in] value The value to add to the range.
     * @return A new range with the specified value added to it.
     * @note N must implement the `+` operator.
     */
    @inline
    operator func +(value: Range<N>) Range<N> {
      // Add the start and end values of the ranges.
      return new Range<N>(self.start + value.start, self.end + value.end); 
    }
    /**
     * @brief Subtracts a value from the range with another range.
     * @param[in] value The value to subtract from the range.
     * @return A new range with the specified value subtracted from it.
     * @note N must implement the `-` operator.
     */
    @inline
    operator func -(value: Range<N>) Range<N> { 
      // Subtract the start and end values of the ranges.
      return new Range<N>(self.start - value.start, self.end - value.end);
    }
    /**
     * @brief Returns a string representation of the range.
     * @return A string representation of the range.
     */
    func to_string<>() String {
      // Return a string representation of the range.
      // We use the `to_string` method of the start and end values
      // to get their string representations.
      // todo: write a `where` statement to the function to make sure
      //  N implements the `to_string` method.
      return self.start.to_string() + ".." + self.end.to_string();
    }

  private:
    /** The start of the range. */
    let start: N = 0;
    /** 
     * The end of the range.
     * @note Do not initialize, it's a basic checker
     *  to make sure the constructor is called 
     */
    let end: N;
};
/**
 * @class Vector
 * @brief A class representing a vector of elements.
 *
 * The `Vector` class serves as a versatile container for managing vectors of elements.
 * It offers a wide range of operations and functionalities, including element insertion,
 * removal, and efficient element access. The class is designed for efficiency and memory
 * safety, automatically handling memory allocation and deallocation required for storing
 * and manipulating vectors.
 *
 * @typeparam _StoreType The type of elements stored in the vector.
 * @typeparam Allocator The allocator type used for memory management (default is `ptr::Allocator<_StoreType>`).
 *
 * @implements Iterable<_StoreType>
 *
 * @note The `Vector` class is designed to be efficient and memory-safe. It provides a high-level
 *       interface for managing collections of elements, abstracting the complexities of memory
 *       management.
 */
public class Vector<T: Sized, Allocator: Sized = ptr::Allocator<T>> 
 implements Iterable<T>, ToString {
  public:
    /**
     * @brief Default constructor.
     * Constructs an empty vector.
     */
    Vector() { self.reset(); }
    /**
     * @brief It pushes an element to the back of the vector.
     * @param[in] value The element to push to the back of the vector.
     */
    mut func push(value: T) {
      // We make sure we have enough capacity to push the element.
      // If we don't, we resize the vector.
      if self.length >= self.capacity {
        // We resize the vector by doubling its capacity.
        self.resize();
      }
      // We push the element to the back of the vector.
      // safety: we make sure we have enough capacity to push the element.
      // we also make sure the buffer is not null.
      unsafe {
        // we write the element to the end of the buffer.
        ptr::write(ptr::add(self.buffer.ptr(), self.length), value);
      }
      // we increment the length of the vector.
      self.length = self.length + 1;
    }
    /**
     * @return The size of the vector.
     */
    @inline
    func size() i32 { return self.length; }
    /**
     * @brief Resizes the vector.
     * @param[in] capacity The new capacity of the vector.
     */
    mut func resize() { 
      // we make sure we dont overflow
      if self.capacity == 0 { self.reserve(1); }
      // Give it a chance before doubling the capacity
      else if self.capacity == 1 { self.reserve(4) }
      // We increase the capacity of the vector by doubling it.
      // Once we are past 4, we increase the capacity by 1.5x. 
      // since we are doubling the capacity, we make sure we don't overflow.
      // and we are kind of expecting a big vector here.
      else self.reserve(self.capacity * 2);
    }
    /**
     * @brief Reserves a capacity for the vector.
     * @param[in] capacity The capacity to reserve for the vector.
     */
    mut func reserve(new_capacity: i32) {
      // If the buffer is null, we allocate a new buffer.
      // If the new capacity is greater than the current capacity,
      // we reallocate the buffer.
      if self.buffer.ptr().is_null() {
        // safety: we make sure the buffer is not null.
        self.buffer = Allocator::alloc(new_capacity);
      } else if self.capacity < new_capacity {
        // safety: we make sure the buffer is not null.
        self.buffer = Allocator::realloc(self.buffer, new_capacity);
      }
      // We update the capacity of the vector.
      self.capacity = new_capacity;
    }
    /**
     * @brief Returns the element at the specified index.
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @note It returns a reference to the element at the specified index.
     */
    @internal_linkage
    func at(index: i32) &mut T {
      // If the index is negative, we return the element at the end of the vector.
      // example: if the vector has 5 elements, and the index is -1, we return the element at index 4.
      //       [0 | 1 | 2 | 3 | 4]
      // ...<-  ^ (0)           ^ (-1) <-...
      if index < 0 {
        // Recursively call the at() method with the index relative to the end of the vector.
        // We make sure we don't overflow.
        return self.at(self.length + index);
      } else if index >= self.length {
        // If the index is greater than or equal to the length of the vector,
        // we throw an IndexError. We make sure we don't overflow.
        throw new IndexError("Index out of bounds.");
      }
      // safety: we make sure the buffer is not null. If the length != 0
      //   that means that the buffer is not null, since we called reserve() before.
      return self.buffer.ptr().unchecked_get(index);
    }
    /**
     * @brief A wrapper over the at() method. 
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @see Vector<_StoreType>::at()
     */
    @inline
    operator func [](index: i32) &mut T 
      { return self.at(index); }
    /**
     * @brief It inserts an element at the specified index.
     * @param[in] index The index to insert the element at.
     * @param[in] value The element to insert.
     */
    @inline
    mut func insert(index: i32, value: T) {
      // If the value is greater than or equal to the length of the vector,
      // we push the value to the back of the vector.
      if index >= self.length {
        self.push(value);
        return;
      }
      // Copy the element at the specified index to a temporary variable.
      let cur = self[index];
      // Set the element at the specified index to the value.
      self[index] = value;
      // We push the temporary variable to the back of the vector.
      self.insert(index + 1, cur);
    }
    /**
     * @brief It returns a string representation of the vector.
     * @return A string representation of the vector.
     */
    func to_string<>() String {
      // We return a string representation of the vector.
      // We iterate over the vector and append each element to the string.
      // We make sure we don't overflow.
      // todo: write a `where` statement to the function to make sure
      //  T implements the `to_string` method.
      let mut result = "[";
      // C-style for loop since it's faster than iterator loops.
      for let mut i = 0; i < self.length; i = i+1 {
        // We append the string representation of the element to the result.
        // note: We don't call to_string here, let StringView do the job.
        result = result + String::from(self[i]);
        // If we are not at the end of the vector, we append a comma.
        if i != self.length - 1 {
          // We append a comma.
          result = result + ", ";
        }
      }
      // We append the closing bracket.
      return result + "]";
    }
    /**
     * @brief It joins the vector into a string.
     * @param[in] sep The separator to use for joining the vector.
     * @return A string containing the joined elements.
     */
    func join<>(sep: String) String {
      // We join the vector into a string.
      let mut result = "";
      // We iterate over the vector and append each element to the result.
      for let mut i = 0; i < self.length; i = i+1 {
        // We append the element to the result.
        result = result + String::from(*self[i]);
        // If we are not at the end of the vector, we append the separator.
        if i != self.length - 1 {
          // We append the separator.
          result = result + sep;
        }
      }
      // We return the result.
      return result;
    }
    /**
     * @brief It returns if the vector is empty.
     * @return `true` if the vector is empty, `false` otherwise.
     */
    @inline
    func empty() bool { return self.length == 0; }
    /**
     * @brief It removes the element at the specified index.
     * @param[in] index The index of the element to remove.
     */
    @inline
    mut func remove(index: i32) {
      if index < 0 {
        throw new IndexError("Index out of bounds. Cannot remove element from a negative index.");
      }
      // We remove the element at the specified index.
      // We make sure we don't overflow.
      // We iterate over the vector and shift each element to the left.
      for let mut i = index; i < self.length - 1; i = i+1 {
        // We shift the element to the left.
        *self[i] = *self[i + 1];
      }
      // We decrement the length of the vector.
      self.length = self.length - 1;
      // we store the last element in a temporary variable, save it from being dropped.
    }
    /**
     * @brief It removes the last element from the vector.
     */
    @inline
    mut func pop() {
      // We remove the last element from the vector.
      // We make sure the vector is not empty.
      if self.empty() {
        throw new IndexError("Cannot pop from an empty vector.");
      }
      // We decrement the length of the vector.
      self.length = self.length - 1;
    }
    /**
     * @brief Returns the next element in the iteration.
     * @return The next element in the iteration.
     */
    virtual mut func next() Iter<T> {
      // Increment the iterator index.
      self.iter_index = self.iter_index + 1;
      // If the iterator index is greater than or equal to the end of the vector,
      // return an invalid iterator.
      if self.iter_index >= self.size() {
        return Iter<?T>::invalid();
      }
      // Otherwise, return a valid iterator with the current iterator index.
      return Iter<?T>::valid(*self[self.iter_index]);
    }
    /**
     * @brief Resets the iteration to the beginning of the range.
     */
    @inline
    virtual mut func reset() { self.iter_index = -1; }

  private:
    /** The capacity of the vector. */
    let mut capacity: i64 = 0;
    /** The size of the vector. */
    let mut length: i64 = 0;
    /** The buffer containing the vector. */
    let mut buffer: ptr::NonNull<T> = Allocator::alloc(0);

  public:
    /**
     * @brief It creates a new Vector with the specified capacity.
     * @param[in] capacity The capacity of the vector.
     * @return A new Vector with the specified capacity.
     */
    @inline
    static func with_capacity(capacity: i32) Self {
      // We create a new vector with the specified capacity.
      let mut vec = new Self();
      // We reserve the specified capacity for the vector.
      vec.reserve(capacity);
      return vec;
    }
}
/**
 * @class StringView
 * @brief A class representing a view of a string of characters.
 *
 * The `StringView` class offers a versatile interface for working with strings of characters.
 * It supports a wide range of string manipulation operations, including concatenation, substring
 * extraction, length calculation, and comparison. This class is designed to be efficient and memory-safe,
 * automatically handling memory allocation and deallocation required for string operations.
 *
 * @typeparam Char The character type of the string (default is `char`).
 *
 * @remarks
 * The `StringView` class is an ideal choice for working with strings without the need for full string
 * ownership or memory management. It provides efficient access and manipulation of string data.
 */
public class StringView<Char: Sized = u8> implements ToString, Clone<Self> {
  public:
    /** A type alias for the string type. */
    type StringType = *const Char;
    /**
     * @brief Default constructor for `StringView`.
     * Constructs an empty string view.
     */
    StringView() {}
    /**
     * @brief Returns the size of the string view.
     * @return The size of the string view.
     */
    @inline
    func size() i32 { return self.length; }
    /**
     * @brief Returns a pointer to the buffer containing the string view.
     * @return A pointer to the buffer containing the string view.
     */
    @inline
    func bytes() StringType { return self.buffer; }
    /**
     * @brief Compares the string view with another string view.
     * @param[in] other The string view to compare with.
     * @return `true` if the string views are equal, `false` otherwise.
     */
    operator func ==(other: Self) bool {
      // If the lengths of the string views are not equal, they are not equal.
      if self.length != other.length {
        return false;
      }
      // We iterate over the string views and compare each character.
      // If the characters are not equal, the string views are not equal.
      // todo: support and test for unicode
      for let mut i = 0; i < self.length; i = i+1 {
        // safety: we make sure the buffer is not null.
        if self.buffer[i] != other.buffer[i] {
          // If the characters are not equal, the string views are not equal.
          return false;
        }
      }
      // If we reach this point, the string views are equal.
      return true;
    }
    /**
     * @brief Checks if the string views are not equal.
     * @param[in] other The string view to compare with.
     * @return `true` if the string views are not equal, `false` otherwise.
     */
    @inline
    operator func !=(other: Self) bool { return !(self == other); }
    /**
     * @brief Concatenates the string view with another string view.
     * @param[in] other The string view to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    operator func +(other: Self) Self { 
      // We concatenate the string views.
      // StringView::concat() will handle the memory allocation and deallocation, 
      // thus we don't have to worry about it.
      let result = Self::concat(self.bytes(), other.bytes(), self.length, other.length); 
      // We return the concatenated string view.
      return new Self(result, self.length + other.length);
    }
    /**
     * @brief Concatenates the string view with a character.
     * @param[in] other The string to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    operator func +(other: Char) Self { 
      // We concatenate the string view with a character.
      // StringView::concat() will handle the memory allocation and deallocation,
      // thus we don't have to worry about it.
      // We pass the character as a pointer to a string of length 1. 
      let result = Self::concat(self.bytes(), (&other) as *const Char, self.length, 1);
      // We return the concatenated string view. 
      return new Self(result, self.length + 1);
    }
    /**
     * @brief Concatenates the string view with a string.
     * @param[in] other The string to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    mut operator func +=(other: Self) Self { *self = *self + other; return self; }
    /**
     * @brief Concatenates the string view with a character.
     * @param[in] other The character to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    mut operator func +=(other: Char) Self { *self = *self + other; return self; }
    /**
     * @brief Converts the string view to a string representation.
     * @return A string representation of the string view.
     */
    @inline
    func to_string() Self { return *self; }
    /**
     * @brief Returns a debug string representation of the string view.
     * @return A debug string representation of the string view.
     */
    @inline
    func debug() Self { return "\"" + *self + "\""; }
    /**
     * @brief Returns the character at the specified index.
     * @param[in] index The index of the character to retrieve.
     * @return The character at the specified index.
     */
    operator func [](index: i32) Char {
      // If the index is negative, we return the character at the end of the string view.
      // example: if the string view has 5 characters, and the index is -1, we return the character at index 4.
      //       [h | e | l | l | o]
      // ...<-  ^ (0)           ^ (-1) <-...
      if index < 0 {
        return self[self.length + index];
      } else if index >= self.length {
        // If the index is greater than or equal to the length of the string view,
        // we throw an IndexError. We make sure we don't overflow.
        // todo: add a better error message
        throw new IndexError("Index out of bounds.");
      }
      // safety: we are praying to the gods that the buffer is not null.
      //  if the buffer is null, we are in trouble. It should never be null.
      //  unless explicitly trying to make us look bad or something whent wrong 
      //  on the C side.
      unsafe {
        // We return the character at the specified index.
        return *(self.bytes() + index);
      }
    }
    /**
     * @brief Returns a substring of the string view.
     * @param[in] range The range of the substring to return.
     * @return The substring of the string view.
     * @note If the range is invalid, the method throws an IndexError.
     */
    func substr(range: Range<i32>) Self {
      // If the range is negative, we return the substring from the end of the string view.
      // example: if the string view has 5 characters, and the range is -1..-3, we return 
      //          the substring from index 4 to index 2.
      if range.begin() < 0 {
        // We make sure we don't overflow.
        return self.substr((self.length + range.begin())..(range.stop()));
      } else if range.stop() < 0 {
        // We make sure we don't overflow. We use recursion to handle the negative range.
        return self.substr((range.begin())..(self.length + range.stop()));
      } else if (range.stop() > self.length) || (range.begin() > self.length) {
        // If the range is invalid, we throw an IndexError.
        // TODO: add a better error message
        throw new IndexError("Index out of bounds.");
      }
      // safety: we make sure the buffer is not null. Unless explicitly trying to make us look bad.
      //  or something whent wrong on the C side. But unless that happens, the buffer should never be null.
      //  therefor, we should be safe. We also know the range is valid, so we don't have to worry about
      //  overflowing.
      unsafe {
        // We return the substring of the string view.
        return new Self(self.bytes() + range.begin(), range.size());
      }
    }
    /**
     * @brief Right adjusts the string view to the specified length. with the specified character.
     * @param[in] length The length to adjust the string view to.
     * @param[in] fill The character to use for adjusting the string view.
     * @return The adjusted string view.
     */
    @inline
    func rjust(length: i32, fill: Char = ' ') Self {
      // If the length is less than or equal to the length of the string view,
      // we return the string view. We don't have to adjust it, therefore we don't
      // have to do anything. Just clone the string view and return it.
      if length <= self.length {
        // note: we clone the string view to make sure we don't modify the original string view.
        return self.clone();
      }
      // Create a new string containing the fill character. 
      // TODO: create string with pre-allocated capacity to avoid reallocation.
      let mut result = "";
      // We iterate over the string view and append the fill character to the result.
      // We make sure we don't overflow.
      for let mut i = 0; i < (length - self.length); i = i+1 {
        // We append the fill character to the result.
        result += fill;
      }
      // We append the string view to the result. 
      return result + self;
    }
    /**
     * @brief Left adjusts the string view to the specified length. with the specified character.
     * @param[in] length The length to adjust the string view to.
     * @param[in] fill The character to use for adjusting the string view.
     * @return The adjusted string view.
     */
    @inline
    func ljust(length: i32, fill: Char = ' ') Self {
      if length <= self.length {
        return self.clone();
      }
      let mut result = self.clone();
      for i in 0..(length - self.length) {
        result += fill;
      }
      return result;
    }
    /**
     * @brief It splits the string view into a vector of substrings.
     * @param[in] sep The separator to use for splitting the string view.
     * @return A vector of substrings.
     */
    func split(sep: Self) Vector<Self> {
      // We split the string view into a vector of substrings.
      let mut result = new Vector<Self>();
      let mut start = 0;
      // We iterate over the string view and split it into substrings.
      // We make sure we don't overflow.
      for let mut i = 0; i < self.length; i = i+1 {
        // If the current character is the separator, we split the string view.
        if self[i] == sep[0] {
          // We append the substring to the result vector.
          result.push(self.substr(start..i));
          // We update the start index.
          start = i + 1;
        }
      }
      if start < self.length {
        // We append the last substring to the result vector.
        result.push(self.substr(start..self.length));
      } 
      // We return the result vector.
      return result;
    }
    /**
     * @brief It clones the string view.
     * @return A clone of the string view.
     */
    @inline
    func clone() Self { return new Self(self.bytes(), self.length); }
    /**
     * @brief It returns if the string view is empty.
     * @return `true` if the string view is empty, `false` otherwise.
     */
    @inline
    func empty() bool { return self.length == 0; }
  private:
    /** A pointer to the buffer containing the string view. */
    let buffer: StringType = zero_initialized!(:StringType);
    /** The size of the string view. */
    let mut length: i32 = 0;

  // Static exports
  public:
    /**
     * @brief Constructs a string view from another string view.
     * @param[in] buffer The string view to construct from.
     * @return The constructed string view.
     */
    @inline
    static func from(buffer: Self) StringView<Char> { return buffer; }

    /**
     * @brief Constructs a string view from an object that implements the `ToString` interface.
     * @param[in] buffer The object to construct the string view from.
     * @return The constructed string view.
     */
    @inline
    static func from<T: ToString>(buffer: T) StringView<Char> { return buffer.to_string(); }

    /**
     * @brief Constructs a string view from a buffer and its size.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @param[in] size The size of the string view.
     * @note Even though it's not marked as unsafe, it's still unsafe to use.
     * @return The constructed string view.
     */
    @inline
    static func from(buffer: *const u8, size: i32) StringView<Char> {
      // We return a string view from the buffer and its size.
      return new Self(buffer, size);
    }

    /**
     * @brief Constructs a string view from a C null-terminated string.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @return The constructed string view.
     */
    @inline
    static unsafe func from_cstr(buffer: *const u8) StringView<Char> {
      if buffer.is_null() {
        // If the buffer is null, we return an empty string view.
        return "";
      }

      // We return a string view from the buffer and its size.
      return new Self(buffer, c_bindings::c_string::strlen(buffer));
    }

  // Internal exports
  private:
    /**
     * @brief Concatenates two string views.
     * @param[in] str1 The first string view to append.
     * @param[in] str2 The second string view to append.
     * @param[in] len1 The length of the first string view.
     * @param[in] len2 The length of the second string view.
     * @return The appended string view.
     */
    static func concat(str1: StringType, str2: StringType,  
      len1: i32, len2: i32) StringType {
      // safety: we make sure the buffer is not null.
      unsafe {
        let sum = len1 + len2;
        // We allocate a buffer to store the concatenated string view.
        let buffer = c_bindings::malloc(sum) as StringType;
        // We copy the first string view to the buffer.
        c_bindings::memcpy(buffer, str1, len1);
        // We copy the second string view to the buffer.
        // We start from the end of the first string view.
        c_bindings::memcpy(buffer + len1, str2, len2);
        // We return the concatenated string view.
        return buffer;
      }
    }
    
  private:
    /**
     * @brief Constructs a string view from a buffer and its size.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @param[in] length The size of the string view.
     */
    StringView(buffer: StringType, length: i32) : buffer(buffer), length(length) {}
}

/**
 * A generic class representing a function, encapsulating a callable entity with 
 * an optional context.
 *
 * This class is designed to wrap any callable entity, such as a function, method, 
 * or closure, and provides an option to associate a context with the function. 
 * The context can be any opaque pointer to additional data that might be needed when 
 * invoking the function.
 * 
 * @tparam T The type of the callable entity. 
 */
public class Function<T: Callable> implements Callable {
  private:
      let fn: T;
      let context: *const void;
  public:
    Function() : fn(zero_initialized!(:T)), context(zero_initialized!(:*const void))
      {} // TODO: remove this
}

// TODO (implement wchar): using WideString as StringView<wchar>

/// --------- COMMANDS ---------

namespace snowball_tests {

@no_inline
@cfg(test)
@export(name = "sn.test.try")
static unsafe func execute(
  fn: func () => i32,
  name: *const i8,
  index: i32,
  skip: bool,
  expect: i32,
  expectStr: *const i8,
  total: i32
) i32 {
  // Get the index as a string, filling the left with zeros, so it's easier to read.
  // This is useful when we have a lot of tests, so we can easily see the index of the test.
  // note: This depends on the total number of tests, so we make sure we don't overflow.
  let indexStr = index.to_string().rjust(total.to_string().size(), '0').bytes();
  // Print the test name.
  // safety: we use printf here, so we make sure the name is null-terminated.
  c_bindings::printf(b" Testing \e[1m%-44s\e[0m [(%s\e[0;30m/%i\e[0m) %s]\t... ", name, indexStr, total, expectStr);
  // Execute the test if it's not skipped. If it's skipped, we just print "wip".
  if !skip {
    // Execute the test and get the result. If the result is equal to the expected result,
    // we print "nice!". Otherwise, we print "error".
    try {
      // note: The compiler makes sure the function is not null and that it follows the correct signature.
      //  so we don't have to worry about that.
      // the function signature is `func () => i32`, so we make sure the result is an integer.
      let result = fn();
      // We check if the result is equal to the expected result.
      if result == expect {
        // If the result is equal to the expected result, we print "nice!".
        c_bindings::printf(b"\e[1;32mnice!\e[0m\n");
      } else {
        // If the result is not equal to the expected result, we print "error".
        // we also print the expected result and the actual result. Again, we use
        // printf, so we make sure the expected result is null-terminated.
        // There hasn't been a case where the expected result is not null-terminated,
        // but we make sure just in case.
        c_bindings::printf(b"\e[1;31merror \n");
        c_bindings::printf(b"\n\tExpected result\e[0m: \e[1;32m%i\e[1;31m\n", expect);
        c_bindings::printf(b"\tActual result\e[0m: \e[1;31m%i\e[0m\n\n", result);
        // We return 0 to indicate that the test failed. We don't return 1 because
        // that's just not how the compiler will handle it. The compiler will return
        // 1 if the test succeeds, and 0 if it fails. So we return 0 if the test fails.
        return false;
      }
    } catch (e: Exception) {
      // We catch any exceptions thrown by the test and print "error".
      // We also print the exception message. 
      c_bindings::printf(b"\e[1;31merror \n");
      c_bindings::printf(b"\n ------- %s failure -------\n", name);
      c_bindings::printf(b"\n  Failed with: \e[1m%s\e[0m\n", e.what().bytes());
      c_bindings::printf(b"\e[0m\n");
      return false;
    }
  } else {
    c_bindings::printf(b"\e[1;33mwip\e[0m\n");
  }
  // We return 1 to indicate that the test succeeded.
  return true;
}

}


@export(name = "sn.bench.run")
@cfg(bench)
@no_inline
func snowball_bench(
  functions: *const *const void,
  names: *const *const u8,
  size: i32,
) {
  if size == 0 { return; }
  let mut results = new Vector<i32>();
  for i in 0..size {
    unsafe {
      let fn = functions[i] as *const void as func () => i32;
      let start = c_bindings::time(ptr::null_ptr<?i32>());
      fn();
      let end = c_bindings::time(ptr::null_ptr<?i32>());
      // unix time to ms
      let result = (end - start) * 1000;
      results.push(result);
    }
  }

  let mut max: i32 = 0;
  let mut min: i32 = 1000000000;
  let mut sum: i32 = 0;
  for i in 0..size {
    let result = *results[i];
    if result > max {
      max = result;
    }
    if result < min {
      min = result;
    }
    sum = sum + result;
  }

  let mut avg: f64 = (sum / size) as f32 as f64;
  for i in 0..size {
    let name = names[i];
    let mut result = (*results[i]);
    let mut color = "\e[1;32m";
    if result > avg {
      color = "\e[1;33m";
    }
    // ms or s
    let mut unit = "ms";
    let mut divider = 1;
    if result >= 1000 {
      unit = "s";
      divider = 1000;
    }
    unsafe {
      c_bindings::printf(b" \e[1m%s\e[0m: %s%i%s\e[0m\n", name, color.bytes(), result / divider, unit.bytes());
    }
  }

  // ms or s
  let mut unit = "ms";
  let mut divider = 1;

  unsafe {
    c_bindings::printf(b"\n\e[1mBenchmark results:\e[0m\n");
    if min >= 1000 {
      unit = "s";
      divider = 1000;
      min = min / divider;
    }
    c_bindings::printf(b" \e[1;32mmin\e[0m: \e[1m%d%s\e[0m\n", min, unit.bytes());
    if max >= 1000 {
      unit = "s";
      divider = 1000;
      max = max / divider;
    } else unit = "ms";
    c_bindings::printf(b" \e[1;31mmax\e[0m: \e[1m%d%s\e[0m\n", max, unit.bytes());
    if avg >= 1000.0 {
      unit = "s";
      divider = 1000;
      avg = avg;
    } else unit = "ms";
  // TODO:
  //  c_bindings::printf(b" \e[1mavg\e[0m: \e[1m%d%s\e[0m\n", avg, unit.bytes());
  }
}

import std::internal::integers;

