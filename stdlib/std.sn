import std::internal::preload;
import std::clib;
import std::ptr;
import std::intrinsics;

type usize = u64; // TODO: make this 32 bit dependent on the target
type isize = i64; // TODO: make this 32 bit dependent on the target

/**
 * @typedef String
 * @brief A type alias for a generic string type.
 *
 * The `String` type alias is used to define a generic string type based on the `StringView` class.
 * This allows you to work with strings in a more flexible and abstract manner. You can use the `String`
 * type for various string manipulation operations and seamlessly switch between different string implementations.
 *
 * @see StringView
 */
public type String = StringView<>;
/**
 * @interface ToString
 * @brief An interface for objects that can be converted to a string representation.
 *
 * The `ToString` interface defines a contract for objects that can be converted to a string
 * representation. Classes implementing this interface must provide the `to_string` method,
 * which returns a string representation of the object.
 */
public interface ToString {
  public:
    /**
     * @brief Converts the object to a string representation.
     * @return A string representation of the object.
     */
    func to_string() String;
};
/**
 * @interface Clone
 * @brief An interface for objects that can be cloned.
 *
 * The `Clone` interface defines a contract for objects that can be cloned. Classes implementing
 * this interface must provide the `clone` method, which returns a clone of the object.
 *
 * @tparam T The type of the object to clone.
 */
public interface Clone<T> {
  public:
    /**
     * @brief Clones the object.
     * @return A clone of the object.
     */
    func clone() T;
};
/**
 * @interface Debug
 * @brief An interface for objects that provide debugging information as a string.
 *
 * The `Debug` interface defines a contract for objects that can provide debugging information
 * as a string. Classes implementing this interface must provide the `debug` method, which
 * returns a string containing debugging details about the object.
 */
public interface Debug {
  public:
    /**
     * @brief Provides debugging information about the object.
     * @return A string containing debugging details.
     */
    func debug() String;
};
/**
 * @interface Throwable
 * @brief An interface for objects that can be thrown as exceptions.
 * 
 * The `Throwable` interface defines a contract for objects that can be thrown as exceptions.
 * Classes implementing this interface must provide the `throw` method, which throws the object
 * as an exception.
 */
public interface Throwable { }
/** 
 * @brief Exception thrown when a null pointer is encountered.
 * 
 * The `NullPointerError` class represents an exception thrown when a null pointer is encountered.
 */
class NullPointerError extends Exception { }
/**
 * @class Exception
 * @brief A class representing an exception.
 *
 * The Exception class provides various operations and functionalities
 * for working with exceptions. It supports common Exception
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
public class Exception implements ToString, Throwable {
  public:
    /**
     * @brief Exception constructor.
     * @param[in] m The message of the exception.
     */ 
    Exception(m: String) : msg(m.c_str()), length(m.size())
      { /* Nothing to do here ðŸ‘‹ */ }
    /**
     * @brief Returns the message of the exception.
     * @return The message of the exception.
     */
    @inline
    func what() String { 
      // Return a string from the message and its length.
      // We store the message as a char pointer and its length
      // so we can easily fetch the message from the C side without
      // having to keep track of snowball's string implementation.
      // This is a bit hacky, but it works. ðŸ˜Š
      return String::from(self.msg, self.length); 
    }
    /**
     * @brief Returns a string representation of the exception.
     * @return A string representation of the exception.
     */
    virtual func to_string() String { return self.what(); }
  private:
    /** The message of the exception. */
    let msg: String::StringType;
    /** The message length */
    let length: i32;
}
/**
 * @class IndexError
 * @brief A class representing an index error.
 *
 * The IndexError class provides various operations and functionalities
 * for working with index errors. It supports common IndexError
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
public class IndexError extends Exception 
  { /* Nothing to do here ðŸ‘‹ */ }
/**
 * @interface Iterable
 * @brief An interface representing an iterable.
 *
 * The `Iterable` interface defines a contract for objects that can be iterated over. It provides
 * various operations and functionalities for working with iterables, allowing you to access
 * elements, iterate through collections, and reset the iteration state if needed.
 *
 * @typeparam IterType The type of elements in the iterable.
 *
 * @remarks This interface is designed to be implemented by classes that represent iterable data structures.
 *  Implementing classes should provide the `next` method to advance the iterator and the `reset` method
 *  to reset the iteration to the beginning if necessary.
 */
public interface Iterable<IterType: Sized> {
    /// @brief The index of the iterator.
    let mut iter_index: i32 = 0;
  public:
    /**
     * @brief Advances the iterator to the next element.
     *
     * The `next` method is used to advance the iterator to the next element in the iterable.
     * It should return the next element as an `Iter<IterType>`.
     *
     * @return The next element in the iterable.
     */
    virtual func next() Iter<IterType>;
    /**
     * @brief Resets the iterator to the beginning of the iterable.
     *
     * The `reset` method is used to reset the iterator's position to the 
     * beginning of the iterable. This can be useful when you need to reiterate 
     * over the collection.
     */
    virtual mut func reset() { self.iter_index = 0; }
}
/**
 * @class Iter
 * @brief A class representing an iterator.
 *
 * The `Iter` class serves as a general-purpose iterator that can be used to traverse collections.
 * It provides various operations and functionalities for working with iterators, allowing you to
 * access elements, determine iterator validity, and retrieve the iterator's value.
 *
 * @tparam T The type of elements that the iterator iterates over.
 *
 * @remarks The `Iter` class can be considered as the reverse of the `Iterable` class and is typically used
 *  to traverse and manipulate data structures that implement the `Iterable` interface. It offers
 *  methods to retrieve the value of the iterator and check its validity.
 */
public class Iter<T: Sized> {
    /// @brief Indicates if the iterator is valid.
    let valid: bool = false;
    /// @brief Stores the value of the iterator.
    let iter_value: T = zero_initialized!(:T);
  public:
    /**
     * @brief Default constructor for `Iter`.
     *
     * This constructor creates an invalid iterator. Use it when you want to create an iterator without
     * specifying an initial value.
     */
    Iter() { /* Nothing to do here ðŸ‘‹ */ }
    /**
     * @brief Constructor for `Iter` with an initial value.
     *
     * This constructor initializes the iterator with a specified value and marks it as valid. It is
     * typically used to create a valid iterator.
     *
     * @param[in] value The initial value of the iterator.
     */
    Iter(value: T) : iter_value(value), valid(true) 
      { /* Still nothing to do here ðŸ˜Š */ }
    /**
     * @brief Returns the value of the iterator.
     * @return The value of the iterator.
     * @throws IndexError if the iterator is invalid.
     */
    @inline
    func value() T {
      // If the iterator is invalid, throw an IndexError.
      // This is useful when you want to access the value of the iterator
      // without checking its validity first.
      if !self.valid {
        // TODO: Add a better error message
        throw new IndexError("Invalid iterator access!");
      }
      // Otherwise, return the value of the iterator.
      return self.iter_value; 
    }
    /**
     * @brief Checks if the iterator is valid.
     * @return `true` if the iterator is valid, `false` otherwise.
     */
    @inline
    func is_valid() bool { return self.valid; }
  public:
    /**
     * @brief Returns an invalid iterator.
     * @return An invalid iterator with no initial value.
     */
    @inline
    static func invalid() Iter<T> { return new Iter<T>(); }
    /**
     * @brief Returns a valid iterator with an initial value.
     * @param[in] val The initial value of the iterator.
     * @return A valid iterator with the specified initial value.
     */
    @inline
    static func valid(val: T) Iter<T> { return new Iter<T>(val); }
}
/**
 * @class Range 
 * @brief A class representing a range of elements.
 *
 * The `Range` class provides a versatile mechanism for working with ranges of elements,
 * such as numerical values. It facilitates common range manipulation operations, including
 * iteration, element access, and range size calculation.
 *
 * @typeparam _Number_Type The type of elements within the range, which must be numeric.
 *
 * @implements Iterable<_Number_Type>
 *
 * @remarks The `Range` class is designed for representing and manipulating ranges of elements. It can
 *  be used for various purposes, including numerical iteration and subsetting. It implements the
 *  `Iterable` interface, making it iterable and compatible with iteration-related utilities.
 */
public class Range<N: Numeric = i32> implements Iterable<N>, ToString {
  public:
    /**
     * @brief Constructor for `Range` with specified start and end values.
     *
     * @param[in] start The start of the range (inclusive).
     * @param[in] end The end of the range (exclusive).
     */
    Range(start: N, end: N) : start(start), end(end) {
      // Reset the iteration to the beginning of the range.
      // In this case, just set the iterator index to the start of the range.
      self.reset();
    }
    /**
     * @brief Constructor for `Range` with a default start value of 0.
     * @param[in] end The end of the range (exclusive).
     */
    Range(end: N) : end(end) { /* Nothing to do here ðŸ‘‹ */ }
    /**
     * @brief Returns the size of the range.
     * @return The size of the range.
     */
    @inline
    func size() N { return self.end - self.start; }
    /**
     * @brief Returns the start of the range.
     * @return The start of the range.
     */
    @inline
    func begin() N { return self.start; }
    /**
     * @brief Returns the end of the range.
     * @return The end of the range.
     */
    @inline
    func stop() N { return self.end; }
    /**
     * @brief Returns the next element in the iteration.
     * @return The next element in the iteration.
     */
    virtual mut func next() Iter<N> {
      // Increment the iterator index.
      self.iter_index = self.iter_index + 1;
      // If the iterator index is greater than or equal to the end of the range,
      // return an invalid iterator.
      if self.iter_index >= self.end {
        return Iter<?N>::invalid();
      }
      // Otherwise, return a valid iterator with the current iterator index.
      return Iter<?N>::valid(self.iter_index);
    }
    /**
     * @brief Resets the iteration to the beginning of the range.
     */
    @inline
    override virtual mut func reset() { self.iter_index = self.start - 1; }
    /**
     * @brief Adds a value to the range with another range.
     * @param[in] value The value to add to the range.
     * @return A new range with the specified value added to it.
     * @note N must implement the `+` operator.
     */
    @inline
    operator func +(value: Range<N>) Range<N> {
      // Add the start and end values of the ranges.
      return new Range<N>(self.start + value.start, self.end + value.end); 
    }
    /**
     * @brief Subtracts a value from the range with another range.
     * @param[in] value The value to subtract from the range.
     * @return A new range with the specified value subtracted from it.
     * @note N must implement the `-` operator.
     */
    @inline
    operator func -(value: Range<N>) Range<N> { 
      // Subtract the start and end values of the ranges.
      return new Range<N>(self.start - value.start, self.end - value.end);
    }
    /**
     * @brief Returns a string representation of the range.
     * @return A string representation of the range.
     */
    func to_string<>() String {
      // Return a string representation of the range.
      // We use the `to_string` method of the start and end values
      // to get their string representations.
      // todo: write a `where` statement to the function to make sure
      //  N implements the `to_string` method.
      return self.start.to_string() + ".." + self.end.to_string();
    }

  private:
    /** The start of the range. */
    let start: N = 0;
    /** 
     * The end of the range.
     * @note Do not initialize, it's a basic checker
     *  to make sure the constructor is called 
     */
    let end: N;
};
/**
 * @class Vector
 * @brief A class representing a vector of elements.
 *
 * The `Vector` class serves as a versatile container for managing vectors of elements.
 * It offers a wide range of operations and functionalities, including element insertion,
 * removal, and efficient element access. The class is designed for efficiency and memory
 * safety, automatically handling memory allocation and deallocation required for storing
 * and manipulating vectors.
 *
 * @typeparam _StoreType The type of elements stored in the vector.
 * @typeparam Allocator The allocator type used for memory management (default is `ptr::Allocator<_StoreType>`).
 *
 * @implements Iterable<_StoreType>
 *
 * @note The `Vector` class is designed to be efficient and memory-safe. It provides a high-level
 *       interface for managing collections of elements, abstracting the complexities of memory
 *       management.
 */
public class Vector<T: Sized, Allocator: Sized = ptr::Allocator<T>> 
 implements Iterable<T>, ToString {
  public:
    /**
     * @brief Default constructor.
     * Constructs an empty vector.
     */
    Vector() { self.reset(); }
    /**
     * @brief It pushes an element to the back of the vector.
     * @param[in] value The element to push to the back of the vector.
     */
    mut func push(value: T) {
      // We make sure we have enough capacity to push the element.
      // If we don't, we resize the vector.
      if self.length >= self.capacity {
        // We resize the vector by doubling its capacity.
        self.resize();
      }
      // We push the element to the back of the vector.
      // safety: we make sure we have enough capacity to push the element.
      // we also make sure the buffer is not null.
      unsafe {
        // we write the element to the end of the buffer.
        ptr::write(self.buffer.ptr() + self.length, value);
      }
      // we increment the length of the vector.
      self.length = self.length + 1;
    }
    /**
     * @brief It returns the length of the vector.
     * @return The size of the vector.
     */
    @inline
    func size() usize { return self.length; }
    /**
     * @brief Resizes the vector.
     * @param[in] capacity The new capacity of the vector.
     */
    mut func resize() { 
      if self.capacity == 0 { self.reserve(1); }
      else if self.capacity == 1 { self.reserve(4) }
      // We increase the capacity of the vector by doubling it.
      // Once we are past 4, we increase the capacity by 1.5x. 
      // since we are doubling the capacity, we make sure we don't overflow.
      // and we are kind of expecting a big vector here.
      else self.reserve(self.capacity * 2);
    }
    /**
     * @brief Reserves a capacity for the vector.
     * @param[in] capacity The capacity to reserve for the vector.
     */
    mut func reserve(new_capacity: usize) {
      // If the buffer is null, we allocate a new buffer.
      // If the new capacity is greater than the current capacity,
      // we reallocate the buffer.
      if self.buffer.ptr().is_null() {
        // safety: we make sure the buffer is not null.
        self.buffer = Allocator::alloc(new_capacity);
      } else if self.capacity < new_capacity {
        // safety: we make sure the buffer is not null.
        self.buffer = Allocator::realloc(self.buffer, new_capacity);
      }
      self.capacity = new_capacity;
    }
    /**
     * @brief Returns the element at the specified index.
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @note It returns a reference to the element at the specified index.
     */
    @internal_linkage
    func at(index: isize) &mut T {
      // If the index is negative, we return the element at the end of the vector.
      // example: if the vector has 5 elements, and the index is -1, we return the element at index 4.
      //       [0 | 1 | 2 | 3 | 4]
      // ...<-  ^ (0)           ^ (-1) <-...
      if index < 0 {
        // Recursively call the at() method with the index relative to the end of the vector.
        // We make sure we don't overflow.
        return self.at(self.length + index);
      } else if index >= self.length {
        throw new IndexError("Index out of bounds.");
      }
      // safety: we make sure the buffer is not null. If the length != 0
      //   that means that the buffer is not null, since we called reserve() before.
      return self.buffer.ptr().unchecked_get(index);
    }
    /**
     * @brief A wrapper over the at() method. 
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @see Vector<_StoreType>::at()
     */
    @inline
    operator func [](index: isize) &mut T { return self.at(index); }
    /**
     * @brief It inserts an element at the specified index.
     * @param[in] index The index to insert the element at.
     * @param[in] value The element to insert.
     */
    @inline
    mut func insert(index: isize, value: T) {
      if index >= self.length {
        self.push(value);
        return;
      }
      let cur = self[index];
      self[index] = value;
      self.insert(index + 1, cur);
    }
    /**
     * @brief It returns a string representation of the vector.
     * @return A string representation of the vector.
     */
    func to_string<>() String {
      // We return a string representation of the vector.
      // We iterate over the vector and append each element to the string.
      // We make sure we don't overflow.
      // todo: write a `where` statement to the function to make sure
      //  T implements the `to_string` method.
      let mut result = "[";
      for let mut i = 0; i < self.length; i = i+1 {
        result = result + self[i].to_string();
        if i != self.length - 1 {
          result = result + ", ";
        }
      }
      // We append the closing bracket.
      return result + "]";
    }
    /**
     * @brief It returns if the vector is empty.
     * @return `true` if the vector is empty, `false` otherwise.
     */
    @inline
    func is_empty() bool { return self.length == 0; }
    /**
     * @brief It removes the element at the specified index.
     * @param[in] index The index of the element to remove.
     */
    @inline
    mut func remove(index: isize) {
      if index < 0 {
        throw new IndexError("Index out of bounds. Cannot remove element from a negative index.");
      }
      // We remove the element at the specified index.
      // We make sure we don't overflow.
      // We iterate over the vector and shift each element to the left.
      for let mut i = index; i < self.length - 1; i = i+1 {
        // We shift the element to the left.
        *self[i] = *self[i + 1];
      }
      // We decrement the length of the vector.
      self.length = self.length - 1;
      // we store the last element in a temporary variable, save it from being dropped.
    }
    /**
     * @brief It removes the last element from the vector.
     */
    @inline
    mut func pop() {
      // We remove the last element from the vector.
      // We make sure the vector is not empty.
      if self.is_empty() {
        throw new IndexError("Cannot pop from an empty vector.");
      }
      // We decrement the length of the vector.
      self.length = self.length - 1;
    }
    /**
     * @brief Returns the next element in the iteration.
     * @return The next element in the iteration.
     */
    virtual mut func next() Iter<T> {
      self.iter_index = self.iter_index + 1;
      if self.iter_index >= self.size() {
        return Iter<?T>::invalid();
      }
      // Otherwise, return a valid iterator with the current iterator index.
      return Iter<?T>::valid(*self[self.iter_index]);
    }
    /**
     * @brief Resets the iteration to the beginning of the range.
     */
    @inline
    override virtual mut func reset() { self.iter_index = -1; }
    /**
     * @brief It finds the first occurrence of an element in the vector.
     * @param[in] value The element to find.
     * @return The index of the first occurrence of the element, or -1 if not found.
     */
    @inline
    func find<>(value: T) isize {
      for let mut i = 0; i < self.length; i = i+1 {
        if self[i] == value {
          return i;
        }
      }
      return -1;
    }

  private:
    /** The capacity of the vector. */
    let mut capacity: usize = 0;
    /** The size of the vector. */
    let mut length: usize = 0;
    /** The buffer containing the vector. */
    let mut buffer: ptr::NonNull<T> = Allocator::alloc(0);

  public:
    /**
     * @brief It creates a new Vector with the specified capacity.
     * @param[in] capacity The capacity of the vector.
     * @return A new Vector with the specified capacity.
     */
    @inline
    static func with_capacity(capacity: usize) Self {
      // We create a new vector with the specified capacity.
      let mut vec = new Self();
      // We reserve the specified capacity for the vector.
      vec.reserve(capacity);
      return vec;
    }
}
/**
 * @class StringView
 * @brief A class representing a view of a string of characters.
 *
 * The `StringView` class offers a versatile interface for working with strings of characters.
 * It supports a wide range of string manipulation operations, including concatenation, substring
 * extraction, length calculation, and comparison. This class is designed to be efficient and memory-safe,
 * automatically handling memory allocation and deallocation required for string operations.
 *
 * @typeparam Char The character type of the string (default is `char`).
 *
 * @remarks The `StringView` class is an ideal choice for working with strings without the need for full string
 *  ownership or memory management. It provides efficient access and manipulation of string data.
 */
public class StringView<Char: Sized = u8> implements ToString, Clone<Self> {
  public:
    /** A type alias for the string type. */
    type StringType = *const Char;
    /**
     * @brief Default constructor for `StringView`.
     * Constructs an empty string view.
     */
    StringView() {}
    /**
     * @brief Returns the size of the string view.
     * @return The size of the string view.
     */
    @inline
    func size() usize { return self.length; }
    /**
     * @brief Returns a pointer to the buffer containing the string view.
     * @return A pointer to the buffer containing the string view.
     */
    @inline
    func bytes() StringType { return self.buffer; }
    /**
     * @brief Returns a c-style string representation of the string view.
     * @return A c-style string representation of the string view.
     */
    @inline
    func c_str() StringType {
      let mut result = ptr::Allocator<?Char>::alloc(self.length + 1);
      // safety: we make sure the buffer is not null.
      unsafe {
        ptr::copy_nonoverlapping(self.buffer, result.ptr(), self.length);
        ptr::write(result.ptr() + self.length, 0 as Char);
      }
      return result.ptr();
    }
    /**
     * @brief Compares the string view with another string view.
     * @param[in] other The string view to compare with.
     * @return `true` if the string views are equal, `false` otherwise.
     */
    operator func ==(other: Self) bool {
      // If the lengths of the string views are not equal, they are not equal.
      if self.length != other.length {
        return false;
      }
      // We iterate over the string views and compare each character.
      // If the characters are not equal, the string views are not equal.
      // todo: support and test for unicode
      for let mut i = 0; i < self.length; i = i+1 {
        // safety: we make sure the buffer is not null.
        if self.buffer[i] != other.buffer[i] {
          // If the characters are not equal, the string views are not equal.
          return false;
        }
      }
      // If we reach this point, the string views are equal.
      return true;
    }
    /**
     * @brief Checks if the string views are not equal.
     * @param[in] other The string view to compare with.
     * @return `true` if the string views are not equal, `false` otherwise.
     */
    @inline
    operator func !=(other: Self) bool { return !(self == other); }
    /**
     * @brief Concatenates the string view with another string view.
     * @param[in] other The string view to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    operator func +(other: Self) Self { 
      // We concatenate the string views.
      // StringView::concat() will handle the memory allocation and deallocation, 
      // thus we don't have to worry about it.
      let result = Self::concat(self.c_str(), other.c_str(), self.length, other.length); 
      // We return the concatenated string view.
      return new Self(result, self.length + other.length);
    }
    /**
     * @brief Concatenates the string view with a character.
     * @param[in] other The string to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    operator func +(other: Char) Self { 
      // We concatenate the string view with a character.
      // StringView::concat() will handle the memory allocation and deallocation,
      // thus we don't have to worry about it.
      // We pass the character as a pointer to a string of length 1. 
      let result = Self::concat(self.c_str(), (&other) as *const Char, self.length, 1);
      // We return the concatenated string view. 
      return new Self(result, self.length + 1);
    }
    /**
     * @brief Concatenates the string view with a string.
     * @param[in] other The string to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    mut operator func +=(other: Self) Self { *self = *self + other; return self; }
    /**
     * @brief Concatenates the string view with a character.
     * @param[in] other The character to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    mut operator func +=(other: Char) Self { *self = *self + other; return self; }
    /**
     * @brief Converts the string view to a string representation.
     * @return A string representation of the string view.
     */
    @inline
    func to_string() Self { return "\"" + *self + "\""; }
    /**
     * @brief Returns a debug string representation of the string view.
     * @return A debug string representation of the string view.
     */
    @inline
    func debug() Self { return "\"" + *self + "\""; }
    /**
     * @brief Returns the character at the specified index.
     * @param[in] index The index of the character to retrieve.
     * @return The character at the specified index.
     */
    operator func [](index: isize) Char {
      // If the index is negative, we return the character at the end of the string view.
      // example: if the string view has 5 characters, and the index is -1, we return the character at index 4.
      //       [h | e | l | l | o]
      // ...<-  ^ (0)           ^ (-1) <-...
      if index < 0 {
        return self[self.length + index];
      } else if index >= self.length {
        // todo: add a better error message
        throw new IndexError("Index out of bounds!");
      }
      // safety: we are praying to the gods that the buffer is not null.
      //  if the buffer is null, we are in trouble. It should never be null.
      //  unless explicitly trying to make us look bad or something whent wrong 
      //  on the C side.
      unsafe {
        // We return the character at the specified index.
        return *(self.c_str() + index);
      }
    }
    /**
     * @brief Returns a substring of the string view.
     * @param[in] range The range of the substring to return.
     * @return The substring of the string view.
     * @note If the range is invalid, the method throws an IndexError.
     */
    func substr(range: Range<i32>) Self {
      if range.begin() < 0 {
        return self.substr((self.length + range.begin())..(range.stop()));
      } else if range.stop() < 0 {
        return self.substr((range.begin())..(self.length + range.stop()));
      } else if (range.stop() > self.length) || (range.begin() > self.length) {
        // TODO: add a better error message
        throw new IndexError("Index out of bounds!");
      }
      // safety: we make sure the buffer is not null. Unless explicitly trying to make us look bad.
      //  or something whent wrong on the C side. But unless that happens, the buffer should never be null.
      //  therefor, we should be safe. We also know the range is valid, so we don't have to worry about
      //  overflowing.
      unsafe {
        return new Self(self.bytes() + range.begin(), range.size());
      }
    }
    /**
     * @brief Returns a substring of the string view.
     * @param[in] index The index of the first character of the substring.
     * @param[in] length The length of the substring.
     * @return The substring of the string view.
     * @note If the range is invalid, the method throws an IndexError.
     */
    @inline
    func substr(index: isize, length: usize) Self { return self.substr(index..(index + length)); }
    /**
     * @brief Returns a substring of the string view.
     * @param[in] index The index of the first character of the substring.
     * @return The substring of the string view.
     * @note If the range is invalid, the method throws an IndexError.
     */
    @inline
    func substr(index: isize) Self { return self.substr(index..self.length); }
    /**
     * @brief It joins the string view with a vector of strings.
     * @param[in] vec The vector of strings to join with.
     * @return The joined string view.
     */
    @inline
    func join(vec: Vector<Self>) Self {
      let mut result = "";
      // C-style for loop since it's faster than iterator loops.
      for let mut i = 0; i < vec.size(); i = i+1 {
        result = result + vec[i];
        if i != vec.size() - 1 {
          result = result + self;
        }
      }
      return result;
    }
    /**
     * @brief Right adjusts the string view to the specified length. with the specified character.
     * @param[in] length The length to adjust the string view to.
     * @param[in] fill The character to use for adjusting the string view.
     * @return The adjusted string view.
     */
    @inline
    func rjust(length: usize, fill: Char = ' ') Self {
      // If the length is less than or equal to the length of the string view,
      // we return the string view. We don't have to adjust it, therefore we don't
      // have to do anything. Just clone the string view and return it.
      if length <= self.length {
        // note: we clone the string view to make sure we don't modify the original string view.
        return self.clone();
      }
      // TODO: create string with pre-allocated capacity to avoid reallocation.
      let mut result = "";
      for let mut i = 0; i < (length - self.length); i = i+1 {
        result += fill;
      }
      return result + self;
    }
    /**
     * @brief Left adjusts the string view to the specified length. with the specified character.
     * @param[in] length The length to adjust the string view to.
     * @param[in] fill The character to use for adjusting the string view.
     * @return The adjusted string view.
     */
    @inline
    func ljust(length: usize, fill: Char = ' ') Self {
      if length <= self.length {
        return self.clone();
      }
      let mut result = self.clone();
      for i in 0..(length - self.length) {
        result += fill;
      }
      return result;
    }
    /**
     * @brief It splits the string view into a vector of substrings.
     * @param[in] sep The separator to use for splitting the string view.
     * @return A vector of substrings.
     */
    func split(sep: Self) Vector<Self> {
      let mut result = new Vector<Self>();
      let mut start = 0;
      for let mut i = 0; i < self.length; i = i+1 {
        if self[i] == sep[0] {
          result.push(self.substr(start..i));
          start = i + 1;
        }
      }
      if start < self.length {
        // We append the last substring to the result vector.
        result.push(self.substr(start..self.length));
      } 
      return result;
    }
    /**
     * @brief It clones the string view.
     * @return A clone of the string view.
     */
    @inline
    func clone() Self { return new Self(self.c_str(), self.length); }
    /**
     * @brief It returns if the string view is empty.
     * @return `true` if the string view is empty, `false` otherwise.
     */
    @inline
    func is_empty() bool { return self.length == 0; }
    /**
     * @brief It returns true if the string view starts with the specified string.
     * @param[in] other The string to check if the string view starts with.
     * @return `true` if the string view starts with the specified string, `false` otherwise.
     */
    @inline
    func starts_with(other: Self) bool {
      if self.length < other.length { return false; }
      for let mut i = 0; i < other.length; i = i+1 {
        if self[i] != other[i] { return false; }
      }
      return true;
    }
    /**
     * @brief It returns true if the string view ends with the specified string.
     * @param[in] other The string to check if the string view ends with.
     * @return `true` if the string view ends with the specified string, `false` otherwise.
     */
    @inline
    func ends_with(other: Self) bool {
      if self.length < other.length { return false; }
      for let mut i = 0; i < other.length; i = i+1 {
        if self[self.length - other.length + i] != other[i] { return false; }
      }
      return true;
    }
  private:
    /** The size of the string view. */
    let mut length: usize = 0;
    /** A pointer to the buffer containing the string view. */
    let mut buffer: StringType = zero_initialized!(:StringType);

  // Static exports
  public:
    /**
     * @brief Constructs a string view from another string view.
     * @param[in] buffer The string view to construct from.
     * @return The constructed string view.
     */
    @inline
    static func from(buffer: Self) StringView<Char> { return buffer; }
    /**
     * @brief Constructs a string view from an object that implements the `ToString` interface.
     * @param[in] buffer The object to construct the string view from.
     * @return The constructed string view.
     */
    @inline
    static func from<T: ToString>(buffer: T) StringView<Char> { return buffer.to_string(); }
    /**
     * @brief Constructs a string view from a buffer and its size.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @param[in] size The size of the string view.
     * @note Even though it's not marked as unsafe, it's still unsafe to use.
     * @return The constructed string view.
     */
    @inline
    static func from(buffer: *const u8, size: usize) StringView<Char> {
      return new Self(buffer, size);
    }
    /**
     * @brief Constructs a string view from a C null-terminated string.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @return The constructed string view.
     */
    @inline
    static unsafe func from_cstr(buffer: *const u8) StringView<Char> {
      if buffer.is_null() {
        return "";
      }
      return new Self(buffer, clib::c_string::strlen(buffer));
    }

  // Internal exports
  private:
    /**
     * @brief Concatenates two string views.
     * @param[in] str1 The first string view to append.
     * @param[in] str2 The second string view to append.
     * @param[in] len1 The length of the first string view.
     * @param[in] len2 The length of the second string view.
     * @return The appended string view.
     */
    static func concat(str1: StringType, str2: StringType,  
      len1: usize, len2: usize) StringType {
      // safety: we make sure the buffer is not null.
      unsafe {
        let sum = len1 + len2;
        let buffer = clib::malloc(sum) as StringType;
        intrinsics::memcpy(buffer, str1, len1);
        intrinsics::memcpy(buffer + len1, str2, len2);
        return buffer;
      }
    }
    
  private:
    /**
     * @brief Constructs a string view from a buffer and its size.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @param[in] length The size of the string view.
     */
    StringView(buffer: StringType, length: usize) : length(length), buffer(ptr::null_ptr<?Char>()) {
      if buffer.is_null() {
        throw new Self::NullPointerError("Cannot construct a string view from a null pointer.");
      }
      // safety: we make sure the buffer is not null.
      unsafe {
        self.buffer = clib::malloc(length) as StringType;
        ptr::copy_nonoverlapping(buffer, self.buffer, length);
      }
    }
}
/**
 * @brief A generic class representing a function, encapsulating a callable entity with 
 *  an optional context.
 *
 * This class is designed to wrap any callable entity, such as a function, method, 
 * or closure, and provides an option to associate a context with the function. 
 * The context can be any opaque pointer to additional data that might be needed when 
 * invoking the function.
 * 
 * @tparam T The type of the callable entity. 
 */
@no_constructor
public class Function<T: Callable> implements Callable {
 private:
  let fn: T;
  let context: *const void;
}

// TODO (implement wchar): using WideString as StringView<wchar>

/// --------- COMMANDS ---------

/**
 * @internal
 * @brief Functions used by the compiler to handle commands. Such as tests and benchmarks.
 * @note These functions are not meant to be used directly.
 */
namespace _snowball_commands_ {

@no_inline
@cfg(tests)
@export(name = "sn.test.try")
static unsafe func execute_tests(
  fn: func () => i32,
  name: *const i8,
  index: i32,
  skip: bool,
  expect: i32,
  expectStr: *const i8,
  total: i32
) i32 {
  // Get the index as a string, filling the left with zeros, so it's easier to read.
  // This is useful when we have a lot of tests, so we can easily see the index of the test.
  // note: This depends on the total number of tests, so we make sure we don't overflow.
  let indexStr = index.to_string().rjust(total.to_string().size(), '0').c_str();
  // safety: we use printf here, so we make sure the name is null-terminated.
  clib::printf(b" Testing \e[1m%-44s\e[0m [(%s\e[0;30m/%i\e[0m) %s]\t... ", name, indexStr, total, expectStr);
  if !skip {
    try {
      // note: The compiler makes sure the function is not null and that it follows the correct signature.
      //  so we don't have to worry about that.
      // the function signature is `func () => i32`, so we make sure the result is an integer.
      let result = fn();
      // We check if the result is equal to the expected result.
      if result == expect {
        // If the result is equal to the expected result, we print "nice!".
        clib::printf(b"\e[1;32mnice!\e[0m\n");
      } else {
        // If the result is not equal to the expected result, we print "error".
        // we also print the expected result and the actual result. Again, we use
        // printf, so we make sure the expected result is null-terminated.
        // There hasn't been a case where the expected result is not null-terminated,
        // but we make sure just in case.
        clib::printf(b"\e[1;31merror \n");
        clib::printf(b"\n\tExpected result\e[0m: \e[1;32m%i\e[1;31m\n", expect);
        clib::printf(b"\tActual result\e[0m: \e[1;31m%i\e[0m\n\n", result);
        // We return 0 to indicate that the test failed. We don't return 1 because
        // that's just not how the compiler will handle it. The compiler will return
        // 1 if the test succeeds, and 0 if it fails. So we return 0 if the test fails.
        return false;
      }
    } catch (e: Exception) {
      // We catch any exceptions thrown by the test and print "error".
      // We also print the exception message. 
      clib::printf(b"\e[1;31merror \n");
      clib::printf(b"\n ------- %s failure -------\n", name);
      clib::printf(b"\n  Failed with: \e[1m%s\e[0m\n", e.what().c_str());
      clib::printf(b"\e[0m\n");
      return false;
    }
  } else {
    clib::printf(b"\e[1;33mwip\e[0m\n");
  }
  // We return 1 to indicate that the test succeeded.
  return true;
}

@export(name = "sn.bench.run")
@cfg(bench)
@no_inline
func snowball_bench(
  functions: *const *const void,
  names: *const *const u8,
  size: i32,
) {
  if size == 0 { return; }
  let mut results = new Vector<i32>();
  for i in 0..size {
    unsafe {
      let fn = functions[i] as *const void as func () => i32;
      let start = clib::time(ptr::null_ptr<?i32>());
      fn();
      let end = clib::time(ptr::null_ptr<?i32>());
      // unix time to ms
      let result = (end - start) * 1000;
      results.push(result);
    }
  }

  let mut max: i32 = 0;
  let mut min: i32 = 1000000000;
  let mut sum: i32 = 0;
  for i in 0..size {
    let result = *results[i];
    if result > max {
      max = result;
    }
    if result < min {
      min = result;
    }
    sum = sum + result;
  }

  let mut avg: f64 = (sum / size) as f32 as f64;
  for i in 0..size {
    let name = names[i];
    let mut result = (*results[i]);
    let mut color = "\e[1;32m";
    if result > avg {
      color = "\e[1;33m";
    }
    // ms or s
    let mut unit = "ms";
    let mut divider = 1;
    if result >= 1000 {
      unit = "s";
      divider = 1000;
    }
    unsafe {
      clib::printf(b" \e[1m%s\e[0m: %s%i%s\e[0m\n", name, color.c_str(), result / divider, unit.c_str());
    }
  }

  // ms or s
  let mut unit = "ms";
  let mut divider = 1;

  unsafe {
    clib::printf(b"\n\e[1mBenchmark results:\e[0m\n");
    if min >= 1000 {
      unit = "s";
      divider = 1000;
      min = min / divider;
    }
    clib::printf(b" \e[1;32mmin\e[0m: \e[1m%d%s\e[0m\n", min, unit.c_str());
    if max >= 1000 {
      unit = "s";
      divider = 1000;
      max = max / divider;
    } else unit = "ms";
    clib::printf(b" \e[1;31mmax\e[0m: \e[1m%d%s\e[0m\n", max, unit.c_str());
    if avg >= 1000.0 {
      unit = "s";
      divider = 1000;
      avg = avg;
    } else unit = "ms";
  // TODO:
  //  clib::printf(b" \e[1mavg\e[0m: \e[1m%d%s\e[0m\n", avg, unit.c_str());
  }
}

}

import std::internal::integers;

