import Core::Internal::Preload;
import Core::CLib;
import Core::Ptr;

type usize = u64; // TODO: make this 32 bit dependent on the target

/**
 * @typedef String
 * @brief A type alias for a generic string type.
 *
 * The `String` type alias is used to define a generic string type based on the `StringView` class.
 * This allows you to work with strings in a more flexible and abstract manner. You can use the `String`
 * type for various string manipulation operations and seamlessly switch between different string implementations.
 *
 * @see StringView
 */
public type String = StringView<>;
/**
 * @interface ToString
 * @brief An interface for objects that can be converted to a string representation.
 *
 * The `ToString` interface defines a contract for objects that can be converted to a string
 * representation. Classes implementing this interface must provide the `to_string` method,
 * which returns a string representation of the object.
 */
public interface ToString {
  public:
    /**
     * @brief Converts the object to a string representation.
     * @return A string representation of the object.
     */
    func to_string() String;
};
/**
 * @interface Clone
 * @brief An interface for objects that can be cloned.
 *
 * The `Clone` interface defines a contract for objects that can be cloned. Classes implementing
 * this interface must provide the `clone` method, which returns a clone of the object.
 *
 * @tparam T The type of the object to clone.
 */
public interface Clone<T> {
  public:
    /**
     * @brief Clones the object.
     * @return A clone of the object.
     */
    func clone() T;
};
/**
 * @interface Debug
 * @brief An interface for objects that provide debugging information as a string.
 *
 * The `Debug` interface defines a contract for objects that can provide debugging information
 * as a string. Classes implementing this interface must provide the `debug` method, which
 * returns a string containing debugging details about the object.
 */
public interface Debug {
  public:
    /**
     * @brief Provides debugging information about the object.
     * @return A string containing debugging details.
     */
    func debug() String;
};
/**
 * @interface Throwable
 * @brief An interface for objects that can be thrown as exceptions.
 * 
 * The `Throwable` interface defines a contract for objects that can be thrown as exceptions.
 * Classes implementing this interface must provide the `throw` method, which throws the object
 * as an exception.
 */
public interface Throwable { }
/**
 * @class Exception
 * @brief A class representing an exception.
 *
 * The Exception class provides various operations and functionalities
 * for working with exceptions. It supports common Exception
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
public class Exception implements ToString, Throwable {
  public:
    /**
     * @brief Exception constructor.
     * @param[in] m The message of the exception.
     */ 
    Exception(m: String) : msg(m.bytes()), length(m.size())
      { }
    /**
     * @brief Returns the message of the exception.
     * @return The message of the exception.
     */
    @inline
    func what() String { 
      return String::from(self.msg, self.length); 
    }
    /**
     * @brief Returns a string representation of the exception.
     * @return A string representation of the exception.
     */
    func to_string() String { return self.what(); }
  private:
    /** The message of the exception. */
    let msg: String::StringType;
    /** The message length */
    let length: i32;
}
/**
 * @class IndexError
 * @brief A class representing an index error.
 *
 * The IndexError class provides various operations and functionalities
 * for working with index errors. It supports common IndexError
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
public class IndexError extends Exception 
  { }
/**
 * @interface Iterable
 * @brief An interface representing an iterable.
 *
 * The `Iterable` interface defines a contract for objects that can be iterated over. It provides
 * various operations and functionalities for working with iterables, allowing you to access
 * elements, iterate through collections, and reset the iteration state if needed.
 *
 * @typeparam IterType The type of elements in the iterable.
 *
 * @remarks
 * This interface is designed to be implemented by classes that represent iterable data structures.
 * Implementing classes should provide the `next` method to advance the iterator and the `reset` method
 * to reset the iteration to the beginning if necessary.
 */
public interface Iterable<IterType: Sized> {
    /// @brief The index of the iterator.
    let mut iter_index: i32 = 0;
  public:
    /**
     * @brief Advances the iterator to the next element.
     *
     * The `next` method is used to advance the iterator to the next element in the iterable.
     * It should return the next element as an `Iter<IterType>`.
     *
     * @return The next element in the iterable.
     */
    virtual func next() Iter<IterType>;
    /**
     * @brief Resets the iterator to the beginning of the iterable.
     *
     * The `reset` method is used to reset the iterator's position to the 
     * beginning of the iterable. This can be useful when you need to reiterate 
     * over the collection.
     */
    virtual mut func reset() { self.iter_index = 0; }
}
/**
 * @class Iter
 * @brief A class representing an iterator.
 *
 * The `Iter` class serves as a general-purpose iterator that can be used to traverse collections.
 * It provides various operations and functionalities for working with iterators, allowing you to
 * access elements, determine iterator validity, and retrieve the iterator's value.
 *
 * @tparam T The type of elements that the iterator iterates over.
 *
 * @remarks
 * The `Iter` class can be considered as the reverse of the `Iterable` class and is typically used
 * to traverse and manipulate data structures that implement the `Iterable` interface. It offers
 * methods to retrieve the value of the iterator and check its validity.
 */
public class Iter<T: Sized> {
    /// @brief Indicates if the iterator is valid.
    let valid: bool = false;
    /// @brief Stores the value of the iterator.
    let iter_value: T = #zero_initialized(:T);
  public:
    /**
     * @brief Default constructor for `Iter`.
     *
     * This constructor creates an invalid iterator. Use it when you want to create an iterator without
     * specifying an initial value.
     */
    Iter() {}
    /**
     * @brief Constructor for `Iter` with an initial value.
     *
     * This constructor initializes the iterator with a specified value and marks it as valid. It is
     * typically used to create a valid iterator.
     *
     * @param[in] value The initial value of the iterator.
     */
    Iter(value: T) : iter_value(value), valid(true) 
      {}
    /**
     * @brief Returns the value of the iterator.
     * @return The value of the iterator.
     * @throws IndexError if the iterator is invalid.
     */
    @inline
    func value() T {
      if !self.valid {
        throw new IndexError("Invalid iterator access!");
      }
      return self.iter_value; 
    }
    /**
     * @brief Checks if the iterator is valid.
     * @return `true` if the iterator is valid, `false` otherwise.
     */
    @inline
    func is_valid() bool { return self.valid; }
  public:
    /**
     * @brief Returns an invalid iterator.
     * @return An invalid iterator with no initial value.
     */
    @inline
    static func invalid() Iter<T> { return new Iter<T>(); }
    /**
     * @brief Returns a valid iterator with an initial value.
     * @param[in] val The initial value of the iterator.
     * @return A valid iterator with the specified initial value.
     */
    @inline
    static func valid(val: T) Iter<T> { return new Iter<T>(val); }
}
/**
 * @class Range 
 * @brief A class representing a range of elements.
 *
 * The `Range` class provides a versatile mechanism for working with ranges of elements,
 * such as numerical values. It facilitates common range manipulation operations, including
 * iteration, element access, and range size calculation.
 *
 * @typeparam _Number_Type The type of elements within the range, which must be numeric.
 *
 * @implements Iterable<_Number_Type>
 *
 * @remarks
 * The `Range` class is designed for representing and manipulating ranges of elements. It can
 * be used for various purposes, including numerical iteration and subsetting. It implements the
 * `Iterable` interface, making it iterable and compatible with iteration-related utilities.
 */
public class Range<N: Numeric = i32> implements Iterable<N>, ToString {
  public:
    /**
     * @brief Constructor for `Range` with specified start and end values.
     *
     * @param[in] start The start of the range (inclusive).
     * @param[in] end The end of the range (exclusive).
     */
    Range(start: N, end: N) : start(start), end(end) {
      self.reset();
    }
    /**
     * @brief Constructor for `Range` with a default start value of 0.
     *
     * @param[in] end The end of the range (exclusive).
     */
    Range(end: N) : end(end) {}
    /**
     * @brief Returns the size of the range.
     * @return The size of the range.
     */
    @inline
    func size() N { return self.end - self.start; }
    /**
     * @brief Returns the start of the range.
     * @return The start of the range.
     */
    @inline
    func begin() N { return self.start; }
    /**
     * @brief Returns the end of the range.
     * @return The end of the range.
     */
    @inline
    func stop() N { return self.end; }
    /**
     * @brief Returns the next element in the iteration.
     * @return The next element in the iteration.
     */
    virtual mut func next() Iter<N> {
      self.iter_index = self.iter_index + 1;
      if self.iter_index >= self.end {
        return Iter<?N>::invalid();
      }
      return Iter<?N>::valid(self.iter_index);
    }
    /**
     * @brief Resets the iteration to the beginning of the range.
     */
    @inline
    virtual mut func reset() { self.iter_index = self.start - 1; }
    /**
     * @brief Adds a value to the range with another range.
     * @param[in] value The value to add to the range.
     * @return A new range with the specified value added to it.
     */
    @inline
    operator func +(value: Range<N>) Range<N> {
      return new Range<N>(self.start + value.start, self.end + value.end); 
    }
    /**
     * @brief Subtracts a value from the range with another range.
     * @param[in] value The value to subtract from the range.
     * @return A new range with the specified value subtracted from it.
     */
    @inline
    operator func -(value: Range<N>) Range<N> { 
      return new Range<N>(self.start - value.start, self.end - value.end);
    }
    /**
     * @brief Returns a string representation of the range.
     * @return A string representation of the range.
     */
    func to_string<>() String {
      return self.start.to_string() + ".." + self.end.to_string();
    }


  private:
    /** The start of the range. */
    let start: N = 0;
    /** 
     * The end of the range.
     * @note Do not initialize, it's a basic checker
     *  to make sure the constructor is called 
     */
    let end: N;
};
/**
 * @class Vector
 * @brief A class representing a vector of elements.
 *
 * The `Vector` class serves as a versatile container for managing vectors of elements.
 * It offers a wide range of operations and functionalities, including element insertion,
 * removal, and efficient element access. The class is designed for efficiency and memory
 * safety, automatically handling memory allocation and deallocation required for storing
 * and manipulating vectors.
 *
 * @typeparam _StoreType The type of elements stored in the vector.
 * @typeparam Allocator The allocator type used for memory management (default is `Ptr::Allocator<_StoreType>`).
 *
 * @implements Iterable<_StoreType>
 *
 * @note The `Vector` class is designed to be efficient and memory-safe. It provides a high-level
 *       interface for managing collections of elements, abstracting the complexities of memory
 *       management.
 */
public class Vector<T: Sized, Allocator: Sized = Ptr::Allocator<T>> 
 implements Iterable<T>, ToString {
  public:
    /**
     * @brief Default constructor.
     * Constructs an empty vector.
     */
    Vector() {}
    /**
     * @brief It pushes an element to the back of the vector.
     * @param[in] value The element to push to the back of the vector.
     */
    mut func push(value: T) {
      if self.length >= self.capacity {
        self.resize();
      }
      unsafe {
        Ptr::write(Ptr::add(self.buffer.ptr(), self.length), value);
      }
      self.length = self.length + 1;
    }
    /**
     * @return The size of the vector.
     */
    @inline
    func size() i32 { return self.length; }
    /**
     * @brief Resizes the vector.
     * @param[in] capacity The new capacity of the vector.
     */
    mut func resize() { 
      // we make sure we dont overflow
      if self.capacity == 0 { self.reserve(1); }
      else if self.capacity == 1 { self.reserve(4) }
      else self.reserve(self.capacity * 2);
    }
    /**
     * @brief Reserves a capacity for the vector.
     * @param[in] capacity The capacity to reserve for the vector.
     */
    mut func reserve(new_capacity: i32) {
      if self.buffer.ptr().is_null() {
        self.buffer = Allocator::alloc(new_capacity);
      } else if self.capacity < new_capacity {
        self.buffer = Allocator::realloc(self.buffer, new_capacity);
      }

      self.capacity = new_capacity;
    }
    /**
     * @brief Returns the element at the specified index.
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @note It returns a reference to the element at the specified index.
     */
    @internal_linkage
    func at(index: i32) &mut T {
      if index < 0 {
        return self.at(self.length + index);
      } else if index >= self.length {
        throw new IndexError("Index out of bounds. Cannot access element at index " + index.to_string());
      }

      return self.buffer.ptr().unchecked_get(index);
    }
    /**
     * @brief A wrapper over the at() method. 
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @see Vector<_StoreType>::at()
     */
    @inline
    operator func [](index: i32) &mut T 
      { return self.at(index); }
    /**
     * @brief It inserts an element at the specified index.
     * @param[in] index The index to insert the element at.
     * @param[in] value The element to insert.
     */
    mut func insert(index: i32, value: T) {
      if index >= self.length {
        self.push(value);
        return;
      }

      let cur = self[index];
      self[index] = value;
      self.insert(index + 1, cur);
    }
    /**
     * @brief It returns a string representation of the vector.
     * @return A string representation of the vector.
     */
    func to_string<>() String {
      let mut result = "[";
      for let mut i = 0; i < self.length; i = i+1 {
        result = result + String::from(self[i]);
        if i != self.length - 1 {
          result = result + ", ";
        }
      }
      return result + "]";
    }

  private:
    /** The capacity of the vector. */
    let mut capacity: i64 = 0;
    /** The size of the vector. */
    let mut length: i64 = 0;
    /** The buffer containing the vector. */
    let mut buffer: Ptr::NonNull<T> = Allocator::alloc(0);

  public:
    /**
     * @brief It creates a new Vector with the specified capacity.
     * @param[in] capacity The capacity of the vector.
     * @return A new Vector with the specified capacity.
     */
    @inline
    static func with_capacity(capacity: i32) Self {
      let mut vec = new Self();
      vec.reserve(capacity);
      return vec;
    }
}
/**
 * @class StringView
 * @brief A class representing a view of a string of characters.
 *
 * The `StringView` class offers a versatile interface for working with strings of characters.
 * It supports a wide range of string manipulation operations, including concatenation, substring
 * extraction, length calculation, and comparison. This class is designed to be efficient and memory-safe,
 * automatically handling memory allocation and deallocation required for string operations.
 *
 * @typeparam Char The character type of the string (default is `char`).
 *
 * @remarks
 * The `StringView` class is an ideal choice for working with strings without the need for full string
 * ownership or memory management. It provides efficient access and manipulation of string data.
 */
public class StringView<Char: Sized = u8> implements ToString, Clone<Self> {
  public:
    /** A type alias for the string type. */
    type StringType = *const Char;
    /**
     * @brief Default constructor for `StringView`.
     * Constructs an empty string view.
     */
    StringView() {}
    /**
     * @brief Returns the size of the string view.
     * @return The size of the string view.
     */
    @inline
    func size() i32 { return self.length; }
    /**
     * @brief Returns a pointer to the buffer containing the string view.
     * @return A pointer to the buffer containing the string view.
     */
    @inline
    func bytes() StringType { return self.buffer; }
    /**
     * @brief Compares the string view with another string view.
     * @param[in] other The string view to compare with.
     * @return `true` if the string views are equal, `false` otherwise.
     */
    operator func ==(other: Self) bool {
      if self.length != other.length {
        return false;
      }
      for let mut i = 0; i < self.length; i = i+1 {
        if self.buffer[i] != other.buffer[i] {
          return false;
        }
      }
      return true;
    }
    /**
     * @brief Checks if the string views are not equal.
     * @param[in] other The string view to compare with.
     * @return `true` if the string views are not equal, `false` otherwise.
     */
    @inline
    operator func !=(other: Self) bool { return !(self == other); }
    /**
     * @brief Concatenates the string view with another string view.
     * @param[in] other The string view to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    operator func +(other: Self) Self { 
      let result = Self::concat(self.bytes(), other.bytes(), self.length, other.length); 
      return new Self(result, self.length + other.length);
    }
    /**
     * @brief Concatenates the string view with a character.
     * @param[in] other The string to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    operator func +(other: Char) Self { 
      let result = Self::concat(self.bytes(), (&other) as *const Char, self.length, 1); 
      return new Self(result, self.length + 1);
    }
    /**
     * @brief Concatenates the string view with a string.
     * @param[in] other The string to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    mut operator func +=(other: Self) Self { *self = *self + other; return self; }
    /**
     * @brief Concatenates the string view with a character.
     * @param[in] other The character to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    mut operator func +=(other: Char) Self { *self = *self + other; return self; }
    /**
     * @brief Converts the string view to a string representation.
     * @return A string representation of the string view.
     */
    @inline
    func to_string() Self { return "\"" + *self + "\""; }
    /**
     * @brief Returns the character at the specified index.
     * @param[in] index The index of the character to retrieve.
     * @return The character at the specified index.
     */
    operator func [](index: i32) Char {
      if index < 0 {
        return self[self.length + index];
      } else if index >= self.length {
        throw new IndexError("Index out of bounds.");
      }
      unsafe {
        return *(self.bytes() + index);
      }
    }
    /**
     * @brief Returns a substring of the string view.
     * @param[in] range The range of the substring to return.
     * @return The substring of the string view.
     * @note If the range is invalid, the method throws an IndexError.
     */
    func substr(range: Range<i32>) Self {
      if range.begin() < 0 {
        return self.substr((self.length + range.begin())..(range.stop()));
      } else if range.stop() < 0 {
        return self.substr((range.begin())..(self.length + range.stop()));
      } else if (range.stop() > self.length) || (range.begin() > self.length) {
        throw new IndexError("Index out of bounds.");
      }
      unsafe {
        return new Self(self.bytes() + range.begin(), range.size());
      }
    }
    /**
     * @brief Right adjusts the string view to the specified length. with the specified character.
     * @param[in] length The length to adjust the string view to.
     * @param[in] fill The character to use for adjusting the string view.
     * @return The adjusted string view.
     */
    @inline
    func rjust(length: i32, fill: Char = ' ') Self {
      if length <= self.length {
        return self.clone();
      }
      let mut result = "";
      for let mut i = 0; i < (length - self.length); i = i+1 {
        result += fill;
      }
      return result + self;
    }
    /**
     * @brief Left adjusts the string view to the specified length. with the specified character.
     * @param[in] length The length to adjust the string view to.
     * @param[in] fill The character to use for adjusting the string view.
     * @return The adjusted string view.
     */
    @inline
    func ljust(length: i32, fill: Char = ' ') Self {
      if length <= self.length {
        return self.clone();
      }
      let mut result = self.clone();
      for i in 0..(length - self.length) {
        result += fill;
      }
      return result;
    }
    /**
     * @brief It clones the string view.
     * @return A clone of the string view.
     */
    @inline
    func clone() Self { return new Self(self.bytes(), self.length); }
  private:
    /** A pointer to the buffer containing the string view. */
    let buffer: StringType = #zero_initialized(:StringType);
    /** The size of the string view. */
    let mut length: i32 = 0;

  // Static exports
  public:
    /**
     * @brief Constructs a string view from another string view.
     * @param[in] buffer The string view to construct from.
     * @return The constructed string view.
     */
    @inline
    static func from(buffer: Self) StringView<Char> { return buffer; }

    /**
     * @brief Constructs a string view from an object that implements the `ToString` interface.
     * @param[in] buffer The object to construct the string view from.
     * @return The constructed string view.
     */
    @inline
    static func from<T: ToString>(buffer: T) StringView<Char> { return buffer.to_string(); }

    /**
     * @brief Constructs a string view from a buffer and its size.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @param[in] size The size of the string view.
     * @return The constructed string view.
     */
    @inline
    static func from(buffer: *const u8, size: i32) StringView<Char> { 
      unsafe {
        return new Self(buffer, size);
      } 
    }

  // Internal exports
  private:
    /**
     * @brief Concatenates two string views.
     * @param[in] str1 The first string view to append.
     * @param[in] str2 The second string view to append.
     * @param[in] len1 The length of the first string view.
     * @param[in] len2 The length of the second string view.
     * @return The appended string view.
     */
    static func concat(str1: StringType, str2: StringType,  
      len1: i32, len2: i32) StringType {
      unsafe {
        let sum = len1 + len2;
        let buffer = CLib::malloc(sum) as StringType;
        CLib::memcpy(buffer, str1, len1);
        CLib::memcpy(buffer + len1, str2, len2);
        return buffer;
      }
    }
    
  private:
    /**
     * @brief Constructs a string view from a buffer and its size.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @param[in] length The size of the string view.
     */
    StringView(buffer: StringType, length: i32) : buffer(buffer), length(length) {}
}

/**
 * A generic class representing a function, encapsulating a callable entity with 
 * an optional context.
 *
 * This class is designed to wrap any callable entity, such as a function, method, 
 * or closure, and provides an option to associate a context with the function. 
 * The context can be any opaque pointer to additional data that might be needed when 
 * invoking the function.
 * 
 * @tparam T The type of the callable entity. 
 */
public class Function<T: Callable> {
  public:  
    struct FunctionData {
      let fn: T;
      let context: *const void;
    }
  private:
    let data: FunctionData;
  public:
    Function(fn: T) : data(FunctionData(fn, Ptr::null_ptr<?void>())) 
      {}
    Function(fn: T, context: *const void) : data(FunctionData(fn, context)) 
      {}
}

// TODO (implement wchar): using WideString as StringView<wchar>

/// --------- COMMANDS ---------

namespace snowball_tests {

@no_inline
@cfg(test)
@export(name = "sn.test.try")
static unsafe func execute(
  fn: func () => i32,
  name: *const i8,
  index: i32,
  skip: bool,
  expect: i32,
  expectStr: *const i8,
  total: i32
) i32 {
  let indexStr = index.to_string().rjust(total.to_string().size(), '0').bytes();
  CLib::printf(b" Testing \e[1m%-44s\e[0m [(%s\e[0;30m/%i\e[0m) %s]\t... ", name, indexStr, total, expectStr);
  // TODO: Add support for exceptions
  if !skip {
    try {
      let result = fn();
      if result == expect {
        CLib::printf(b"\e[1;32mnice!\e[0m\n");
      } else {
        CLib::printf(b"\e[1;31merror \n");
        CLib::printf(b"\n\tExpected result\e[0m: \e[1;32m%i\e[1;31m\n", expect);
        CLib::printf(b"\tActual result\e[0m: \e[1;31m%i\e[0m\n\n", result);
        return false;
      }
    } catch (e: Exception) {
      CLib::printf(b"\e[1;31merror \n");
      CLib::printf(b"\n ------- %s failure -------\n", name);
      CLib::printf(b"\n  Failed with: \e[1m%s\e[0m\n", e.what().bytes());
      CLib::printf(b"\e[0m\n");
      return false;
    }
  } else {
    CLib::printf(b"\e[1;33mwip\e[0m\n");
  }
  return true;
}

}

//func [[
//  export(name = "sn.bench.run"),
//  cfg(bench),
//  no_inline
//]] snowball_bench(
//  functions: *const func () => void,
//  names: *const char,
//  size: i32,
//) {
//  if size == 0 { return; }
//  let mut results = new Vector<i32>();
//  for i in 0..size {
//    unsafe {
//      //let fn = functions[i] as *const void as func () => i32;
//      let start = CLib::time(Ptr::null_ptr<?i32>());
//      //fn();
//      let end = CLib::time(Ptr::null_ptr<?i32>());
//      // unix time to ms
//      let result = (end - start) * 1000;
//      results.push(result);
//    }
//  }
//
//  let mut max: i32 = 0;
//  let mut min: i32 = 1000000000;
//  let mut sum: i32 = 0;
//  for i in 0..size {
//    let result = *results[i];
//    if result > max {
//      max = result;
//    }
//    if result < min {
//      min = result;
//    }
//    sum = sum + result;
//  }
//
//  let mut avg: f32 = sum / size;
//  for i in 0..size {
//    let name = names[i];
//    let mut result = (*results[i]) as f64;
//    let mut color = "\e[1;32m";
//    if result > avg {
//      color = "\e[1;31m";
//    }
//    // ms or s
//    let mut unit = "ms";
//    let mut divider = 1;
//    if result >= 1000.0 {
//      unit = "s";
//      divider = 1000;
//    }
//    unsafe {
//      CLib::printf(@c_str(" \e[1m%s\e[0m: %s%f%s\e[0m\n"), name, color.bytes(), result / divider, unit.bytes());
//    }
//  }
//
//  // ms or s
//  let mut unit = "ms";
//  let mut divider = 1;
//
//  unsafe {
//    CLib::printf(@c_str("\n"));
//    if min >= 1000 {
//      unit = "s";
//      divider = 1000;
//      min = min / divider;
//    }
//    CLib::printf(@c_str(" \e[1;32mmin\e[0m: %d%s\n"), min, unit);
//    if max >= 1000 {
//      unit = "s";
//      divider = 1000;
//      max = max / divider;
//    } else unit = "ms";
//    CLib::printf(@c_str(" \e[1;31mmax\e[0m: %d%s\n"), max, unit);
//    if avg >= 1000 {
//      unit = "s";
//      divider = 1000;
//      avg = avg / divider;
//    } else unit = "ms";
//    CLib::printf(@c_str(" \e[1mavg\e[0m: %d%s\n"), avg, unit);
//  }
//}

import Core::Internal::Integer;
