import Core::Internal::Preload;
@use_macro(c_str) 
import Core::CLib;
import Core::Ptr;

const DEC_DIGITS_LUT: *const u8 = b"\
0001020304050607080910111213141516171819\
2021222324252627282930313233343536373839\
4041424344454647484950515253545556575859\
6061626364656667686970717273747576777879\
8081828384858687888990919293949596979899";

@extends
@__internal__
class IntegerImpl {  
  public:
    func to_string(self: IntegerType) String {
      // TODO: static assert sizeof is larger than 2
      // TODO: float impl
      let mut n = self;
      let mut curr = 39; // max number of digits for the buffer
      let mut buffer = Ptr::Allocator<?u8>::alloc(curr).ptr();
      let mut neg = false;
      if n < 0 {
        neg = true;
        n = -n;
        curr = curr - 1;
      }
      unsafe {
        let mut n = n as usize;
        while n >= 10000 {
          let rem = (n % 10000) as usize;
          n = n / 10000;
          let d1 = (rem / 100) as usize << 1;
          let d2 = (rem % 100) << 1;
          curr = curr - 4;
          // we know that buffer > 0 so we can safely write to it
          // TODO: assert curr >= 0
          Ptr::copy_nonoverlapping(DEC_DIGITS_LUT + d1, buffer + curr, 2);
          Ptr::copy_nonoverlapping(DEC_DIGITS_LUT + d2, buffer + (curr + 2), 2);
        }
        {
          if n >= 100 {
            let d1 = (n % 100) << 1; // >> get the last 2 digits
            n = n / 100 as usize;
            curr = curr - 2;
            Ptr::copy_nonoverlapping(DEC_DIGITS_LUT + d1, buffer + curr, 2);
          }
          // decode last 1 or 2 chars
          if n < 10 {
            curr = curr - 1;
            *(buffer + curr) = (n as u8) + '0';
          } else {
            let d1 = n << 1; // >> get the last 2 digits
            curr = curr - 2;
            Ptr::copy_nonoverlapping(DEC_DIGITS_LUT + d1, buffer + curr, 2);
          }
        }
        if neg {
          curr = curr - 1;
          *(buffer + curr) = '-';
        }
        return String::from(buffer + curr, 39 - (curr+neg));
      }
    }

    // TODO: this is just a hack, we need to implement a proper
    //    implementation for to_string for bool and floats
    func to_string(self: bool) String {
      if self { return "1" }
      else { return "0" }
    }

    func hex(self: IntegerType) String {
      let mut x = self as usize;
      let size = 17; // max number of digits for the buffer
      let mut buffer = Ptr::Allocator<?u8>::alloc(size).ptr();
      unsafe {
        let mut i = size - 1;
        while i >= 2 {
          let d: u8 = x & 0xF;
          let mut c: u8;
          if d < 10 {
            c = d + '0';
          } else {
            c = d + 55;
          }
          *(buffer + i) = c;
          i = i - 1;
          x = x >> 4;
        }
        *(buffer + 0) = '0';
        *(buffer + 1) = 'x';
        return String::from(buffer, size);
      }
    }
}

type usize = u64; // TODO: make this 32 bit dependent on the target

/**
 * @typedef String
 * @brief A type alias for a generic string type.
 *
 * The `String` type alias is used to define a generic string type based on the `StringView` class.
 * This allows you to work with strings in a more flexible and abstract manner. You can use the `String`
 * type for various string manipulation operations and seamlessly switch between different string implementations.
 *
 * @see StringView
 */
public type String = StringView<>;
/**
 * @interface ToString
 * @brief An interface for objects that can be converted to a string representation.
 *
 * The `ToString` interface defines a contract for objects that can be converted to a string
 * representation. Classes implementing this interface must provide the `to_string` method,
 * which returns a string representation of the object.
 */
public interface ToString {
  public:
    /**
     * @brief Converts the object to a string representation.
     * @return A string representation of the object.
     */
    func to_string() String;
};
/**
 * @interface Debug
 * @brief An interface for objects that provide debugging information as a string.
 *
 * The `Debug` interface defines a contract for objects that can provide debugging information
 * as a string. Classes implementing this interface must provide the `debug` method, which
 * returns a string containing debugging details about the object.
 */
public interface Debug {
  public:
    /**
     * @brief Provides debugging information about the object.
     * @return A string containing debugging details.
     */
    func debug() String;
};
/**
 * @class Exception
 * @brief A class representing an exception.
 *
 * The Exception class provides various operations and functionalities
 * for working with exceptions. It supports common Exception
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
public class Exception implements ToString {
  public:
    /**
     * @brief Exception constructor.
     * @param[in] m The message of the exception.
     */ 
    Exception(m: String) : msg(m.bytes()), length(m.size())
      { }
    /**
     * @brief Returns the message of the exception.
     * @return The message of the exception.
     */
    func what() String
      { return String::from(self.msg, self.length); }

    /**
     * @brief Returns a string representation of the exception.
     * @return A string representation of the exception.
     */
    func to_string() String
      { return self.what(); }
  private:
    /** The message of the exception. */
    let msg: String::StringType;
    /** The message length */
    let length: i32;
}
/**
 * @class IndexError
 * @brief A class representing an index error.
 *
 * The IndexError class provides various operations and functionalities
 * for working with index errors. It supports common IndexError
 * manipulation operations such as exception throwing, exception
 * catching, exception handling, and more.
 */
public class IndexError extends Exception 
  { }
/**
 * @interface Iterable
 * @brief An interface representing an iterable.
 *
 * The `Iterable` interface defines a contract for objects that can be iterated over. It provides
 * various operations and functionalities for working with iterables, allowing you to access
 * elements, iterate through collections, and reset the iteration state if needed.
 *
 * @typeparam IterType The type of elements in the iterable.
 *
 * @remarks
 * This interface is designed to be implemented by classes that represent iterable data structures.
 * Implementing classes should provide the `next` method to advance the iterator and the `reset` method
 * to reset the iteration to the beginning if necessary.
 */
public interface Iterable<IterType: Sized> {
    let mut iter_index: i32 = 0;
  public:
    /**
     * @brief Advances the iterator to the next element.
     *
     * The `next` method is used to advance the iterator to the next element in the iterable.
     * It should return the next element as an `Iter<IterType>`.
     *
     * @return The next element in the iterable.
     */
    virtual func next() Iter<IterType>;
    
    /**
     * @brief Resets the iterator to the beginning of the iterable.
     *
     * The `reset` method is used to reset the iterator's position to the beginning of the iterable.
     * This can be useful when you need to reiterate over the collection.
     */
    virtual mut func reset() { self.iter_index = 0; }
}
/**
 * @class Iter
 * @brief A class representing an iterator.
 *
 * The `Iter` class serves as a general-purpose iterator that can be used to traverse collections.
 * It provides various operations and functionalities for working with iterators, allowing you to
 * access elements, determine iterator validity, and retrieve the iterator's value.
 *
 * @typeparam _IteratorType The type of elements that the iterator iterates over.
 *
 * @remarks
 * The `Iter` class can be considered as the reverse of the `Iterable` class and is typically used
 * to traverse and manipulate data structures that implement the `Iterable` interface. It offers
 * methods to retrieve the value of the iterator and check its validity.
 */
public class Iter<_IteratorType: Sized> {
    /// @brief Indicates if the iterator is valid.
    let _valid: bool = false;
    /// @brief Stores the value of the iterator.
    let _value: _IteratorType = @zero_initialized(:_IteratorType);
  public:
    /**
     * @brief Default constructor for `Iter`.
     *
     * This constructor creates an invalid iterator. Use it when you want to create an iterator without
     * specifying an initial value.
     */
    Iter() {}
    /**
     * @brief Constructor for `Iter` with an initial value.
     *
     * This constructor initializes the iterator with a specified value and marks it as valid. It is
     * typically used to create a valid iterator.
     *
     * @param[in] value The initial value of the iterator.
     */
    Iter(value: _IteratorType) : _value(value),
      _valid(true) {}
    /**
     * @brief Returns the value of the iterator.
     * @return The value of the iterator.
     * @throws IndexError if the iterator is invalid.
     */
    @internal_linkage
    @inline
    func value() _IteratorType 
    { 
      if !self._valid 
      {
        throw new IndexError("Invalid iterator access!");
      }
      return &self._value; 
    }
    /**
     * @brief Checks if the iterator is valid.
     * @return `true` if the iterator is valid, `false` otherwise.
     */
    @internal_linkage
    @inline
    func is_valid() bool 
      { return self._valid; }
  public:
    /**
     * @brief Returns an invalid iterator.
     * @return An invalid iterator with no initial value.
     */
    @inline
    static func invalid() Iter<_IteratorType> 
      { return new Iter<_IteratorType>(); }
    /**
     * @brief Returns a valid iterator with an initial value.
     * @param[in] val The initial value of the iterator.
     * @return A valid iterator with the specified initial value.
     */
    @inline
    static func valid(val: _IteratorType) Iter<_IteratorType> 
      { return new Iter<_IteratorType>(val); }
}
/**
 * @class Range 
 * @brief A class representing a range of elements.
 *
 * The `Range` class provides a versatile mechanism for working with ranges of elements,
 * such as numerical values. It facilitates common range manipulation operations, including
 * iteration, element access, and range size calculation.
 *
 * @typeparam _Number_Type The type of elements within the range, which must be numeric.
 *
 * @implements Iterable<_Number_Type>
 *
 * @remarks
 * The `Range` class is designed for representing and manipulating ranges of elements. It can
 * be used for various purposes, including numerical iteration and subsetting. It implements the
 * `Iterable` interface, making it iterable and compatible with iteration-related utilities.
 */
public class Range<_Number_Type: Numeric = i32> implements Iterable<_Number_Type> {
  public:
    /**
     * @brief Constructor for `Range` with specified start and end values.
     *
     * @param[in] start The start of the range (inclusive).
     * @param[in] end The end of the range (exclusive).
     */
    Range(start: _Number_Type, end: _Number_Type) : 
      _start(start), _end(end) 
    {
      self.iter_index = self._start - 1;
    }
    /**
     * @brief Constructor for `Range` with a default start value of 0.
     *
     * @param[in] end The end of the range (exclusive).
     */
    Range(end: _Number_Type) : _end(end) {}
    /**
     * @brief Returns the size of the range.
     * @return The size of the range.
     */
    @inline
    func size() _Number_Type
      { return self._end - self._start; }
    /**
     * @brief Returns the start of the range.
     * @return The start of the range.
     */
    @internal_linkage
    @inline
    func begin() _Number_Type
      { return self._start; }
    /**
     * @brief Returns the end of the range.
     * @return The end of the range.
     */
    @internal_linkage
    @inline
    func end() _Number_Type
      { return self._end; }
    /**
     * @brief Returns the next element in the iteration.
     * @return The next element in the iteration.
     */
    virtual mut func next() Iter<_Number_Type>
    {
      self.iter_index = self.iter_index + 1;
      if self.iter_index >= self.end() 
      {
        return Iter<?_Number_Type>::invalid();
      }
      return Iter<?_Number_Type>::valid(self.iter_index);
    }
    /**
     * @brief Resets the iteration to the beginning of the range.
     */
    @inline
    mut func reset() { self.iter_index = self._start - 1; }
  private:
    /** The start of the range. */
    let _start: _Number_Type = 0;
    /** The end of the range. */
    let _end: _Number_Type;
};
/**
 * @class Vector
 * @brief A class representing a vector of elements.
 *
 * The `Vector` class serves as a versatile container for managing vectors of elements.
 * It offers a wide range of operations and functionalities, including element insertion,
 * removal, and efficient element access. The class is designed for efficiency and memory
 * safety, automatically handling memory allocation and deallocation required for storing
 * and manipulating vectors.
 *
 * @typeparam _StoreType The type of elements stored in the vector.
 * @typeparam Allocator The allocator type used for memory management (default is `Ptr::Allocator<_StoreType>`).
 *
 * @implements Iterable<_StoreType>
 *
 * @note The `Vector` class is designed to be efficient and memory-safe. It provides a high-level
 *       interface for managing collections of elements, abstracting the complexities of memory
 *       management.
 */
public class Vector<
  _StoreType: Sized,
  Allocator: Sized = Ptr::Allocator<_StoreType>
> implements Iterable<_StoreType>, ToString {
  public:
    /**
     * @brief Default constructor.
     * Constructs an empty vector.
     */
    Vector() {}
    /**
     * @brief It pushes an element to the back of the vector.
     * @param[in] value The element to push to the back of the vector.
     */
    mut func push(value: _StoreType)
    { 
      if self.length >= self.capacity 
      {
        self.resize();
      }
      unsafe {
        Ptr::write(Ptr::add(self.buffer.ptr(), self.length), value);
      }
      self.length = self.length + 1;
    }
    /**
     * @return The size of the vector.
     */
    @internal_linkage
    @inline
    func size() i32 { return self.length; }
    /**
     * @brief Resizes the vector.
     * @param[in] capacity The new capacity of the vector.
     */
    mut func resize()
    { 
      // we make sure we dont overflow
      if self.capacity == 0 { self.reserve(1); }
      else if self.capacity == 1 { self.reserve(4) }
      else self.reserve(self.capacity * 2);
    }
    /**
     * @brief Reserves a capacity for the vector.
     * @param[in] capacity The capacity to reserve for the vector.
     */
    mut func reserve(new_capacity: i32)
    {
      if self.buffer.ptr().is_null() 
      {
        self.buffer = Allocator::alloc(new_capacity);
      } else if self.capacity < new_capacity 
      {
        self.buffer = Allocator::realloc(self.buffer, new_capacity);
      }
      self.capacity = new_capacity;
    }
    /**
     * @brief Returns the element at the specified index.
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @note It returns a reference to the element at the specified index.
     */
    @internal_linkage
    func at(index: i32) &mut _StoreType
    {
      if index < 0 
      {
        return self.at(self.length + index);
      } 
      else if index >= self.length 
      {
        throw new IndexError("Index out of bounds. Cannot access element at index " + index.to_string());
      }
      return self.buffer.ptr().unchecked_get(index);
    }
    /**
     * @brief A wrapper over the at() method. 
     * @param[in] index The index of the element to return.
     * @return The element at the specified index.
     * @see Vector<_StoreType>::at()
     */
    @inline
    operator func [](index: i32) &mut _StoreType
      { return self.at(index); }
    /**
     * @brief It inserts an element at the specified index.
     * @param[in] index The index to insert the element at.
     * @param[in] value The element to insert.
     */
    mut func insert(index: i32, value: _StoreType)
    {
      if index >= self.length 
      {
        self.push(value);
        return;
      }
      let cur = self[index];
      self[index] = value;
      self.insert(index + 1, cur);
    }
    /**
     * @brief It returns a string representation of the vector.
     * @return A string representation of the vector.
     */
    func to_string<>() String {
      let mut result = "[";
      for i in 0..self.length {
        result = result + String::from(self[i]);
        if i != self.length - 1 {
          result = result + ", ";
        }
      }
      return result + "]";
    }

  private:
    /** The capacity of the vector. */
    let mut capacity: i64 = 0;
    /** The size of the vector. */
    let mut length: i64 = 0;
    /** The buffer containing the vector. */
    let mut buffer: Ptr::NonNull<_StoreType> = Allocator::alloc(0);

  public:
    /**
     * @brief It creates a new Vector with the specified capacity.
     * @param[in] capacity The capacity of the vector.
     * @return A new Vector with the specified capacity.
     */
    @inline
    static func with_capacity(capacity: i32) Self 
    {
      let mut vec = new Self();
      vec.reserve(capacity);
      return vec;
    }
      
}
/**
 * @class StringView
 * @brief A class representing a view of a string of characters.
 *
 * The `StringView` class offers a versatile interface for working with strings of characters.
 * It supports a wide range of string manipulation operations, including concatenation, substring
 * extraction, length calculation, and comparison. This class is designed to be efficient and memory-safe,
 * automatically handling memory allocation and deallocation required for string operations.
 *
 * @typeparam Char The character type of the string (default is `char`).
 *
 * @remarks
 * The `StringView` class is an ideal choice for working with strings without the need for full string
 * ownership or memory management. It provides efficient access and manipulation of string data.
 */
public class StringView<Char: Sized = u8> implements ToString {
  public:
    type StringType = *const Char;

    /**
     * @brief Default constructor for `StringView`.
     * Constructs an empty string view.
     */
    StringView() {}

    /**
     * @brief Returns the size of the string view.
     * @return The size of the string view.
     */
    @inline
    func size() i32 { return self.length; }

    /**
     * @brief Returns a pointer to the buffer containing the string view.
     * @return A pointer to the buffer containing the string view.
     */
    @inline
    func bytes() StringType { return self.buffer; }

    /**
     * @brief Compares the string view with another string view.
     * @param[in] other The string view to compare with.
     * @return `true` if the string views are equal, `false` otherwise.
     */
    operator func ==(other: Self) bool {
      if self.length != other.length {
        return false;
      }
      for i in 0..self.length {
        if self.buffer[i] != other.buffer[i] {
          return false;
        }
      }
      return true;
    }

    /**
     * @brief Checks if the string views are not equal.
     * @param[in] other The string view to compare with.
     * @return `true` if the string views are not equal, `false` otherwise.
     */
    @inline
    operator func !=(other: Self) bool { return !(self == other); }

    /**
     * @brief Concatenates the string view with another string view.
     * @param[in] other The string view to concatenate with.
     * @return The concatenated string view.
     */
    @inline
    operator func +(other: Self) Self { 
      let result = Self::concat(self.bytes(), other.bytes(), self.length, other.length); 
      return new Self(result, self.length + other.length);
    }

    /**
     * @brief Converts the string view to a string representation.
     * @return A string representation of the string view.
     */
    @inline
    func to_string() Self { return "\"" + *self + "\""; }

    /**
     * @brief Returns the character at the specified index.
     * @param[in] index The index of the character to retrieve.
     * @return The character at the specified index.
     */
    operator func [](index: i32) Char {
      if index < 0 {
        return self[self.length + index];
      } else if index >= self.length {
        throw new IndexError("Index out of bounds.");
      }
      unsafe {
        return *(self.bytes() + index);
      }
    }
    
  private:
    /** The size of the string view. */
    let mut length: i32 = 0;
    /** A pointer to the buffer containing the string view. */
    let buffer: StringType = @zero_initialized(:StringType);

  // Static exports
  public:
    /**
     * @brief Constructs a string view from another string view.
     * @param[in] buffer The string view to construct from.
     * @return The constructed string view.
     */
    @inline
    static func from(buffer: Self) StringView<Char> { return buffer; }

    /**
     * @brief Constructs a string view from an object that implements the `ToString` interface.
     * @param[in] buffer The object to construct the string view from.
     * @return The constructed string view.
     */
    @inline
    static func from<T: ToString>(buffer: T) StringView<Char> { return buffer.to_string(); }

    /**
     * @brief Constructs a string view from a buffer and its size.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @param[in] size The size of the string view.
     * @return The constructed string view.
     */
    @inline
    static func from(buffer: *const u8, size: i32) StringView<Char> { 
      unsafe {
        return new Self(buffer, size);
      } 
    }

  // Internal exports
  private:
    /**
     * @brief Concatenates two string views.
     * @param[in] str1 The first string view to append.
     * @param[in] str2 The second string view to append.
     * @param[in] len1 The length of the first string view.
     * @param[in] len2 The length of the second string view.
     * @return The appended string view.
     */
    static func concat(str1: StringType, str2: StringType,  
      len1: i32, len2: i32) StringType {
      unsafe {
        let sum = len1 + len2;
        let buffer = CLib::malloc(sum) as StringType;
        CLib::memcpy(buffer, str1, len1);
        CLib::memcpy(buffer + len1, str2, len2);
        return buffer;
      }
    }
    
  private:
    /**
     * @brief Constructs a string view from a buffer and its size.
     * @param[in] buffer A pointer to the buffer containing the string view.
     * @param[in] length The size of the string view.
     */
    StringView(buffer: StringType, length: i32) : buffer(buffer), length(length) {}
}

// TODO (implement wchar): using WideString as StringView<wchar>

/// --------- COMMANDS ---------


@no_inline
@cfg(test)
@export(name = "sn.test.try")
static unsafe func snowball_test(
  fn: func () => i32,
  name: *const i8,
  index: i32,
  skip: bool,
  expect: i32,
  expectStr: *const i8,
  total: i32
) i32 {
  CLib::printf(@c_str(" Testing (\e[1m%i/%i\e[0m) \t\e[1m%-45s\e[0m [%s]\t... "), index, total, name, expectStr);
  // TODO: Add support for exceptions
  if !skip {
    try {
      let result = fn();
      if result == expect {
        CLib::printf(@c_str("\e[1;32mnice!\e[0m\n"));
      } else {
        CLib::printf(@c_str("\e[1;31merror \n"));
        CLib::printf(@c_str("\n UNEXPECTED RESULT:\n"));
        CLib::printf(@c_str("   --> Expected a success return value (%i) but got `%i`\n"), expect, result);
        CLib::printf(@c_str("\e[0m\n"));
        return false;
      }
    } catch (e: Exception) {
      CLib::printf(@c_str("\e[1;31merror \n"));
      CLib::printf(@c_str("\n UNEXPECTED EXCEPTION:\n"));
      CLib::printf(@c_str("   --> %s\n"), e.what().bytes());
      CLib::printf(@c_str("\e[0m\n"));
      return false;
    }
  } else {
    CLib::printf(@c_str("\e[1;33mwip\e[0m\n"));
  }
  return true;
}

//func [[
//  export(name = "sn.bench.run"),
//  cfg(bench),
//  no_inline
//]] snowball_bench(
//  functions: *const func () => void,
//  names: *const char,
//  size: i32,
//) {
//  if size == 0 { return; }
//  let mut results = new Vector<i32>();
//  for i in 0..size {
//    unsafe {
//      //let fn = functions[i] as *const void as func () => i32;
//      let start = CLib::time(Ptr::null_ptr<?i32>());
//      //fn();
//      let end = CLib::time(Ptr::null_ptr<?i32>());
//      // unix time to ms
//      let result = (end - start) * 1000;
//      results.push(result);
//    }
//  }
//
//  let mut max: i32 = 0;
//  let mut min: i32 = 1000000000;
//  let mut sum: i32 = 0;
//  for i in 0..size {
//    let result = *results[i];
//    if result > max {
//      max = result;
//    }
//    if result < min {
//      min = result;
//    }
//    sum = sum + result;
//  }
//
//  let mut avg: f32 = sum / size;
//  for i in 0..size {
//    let name = names[i];
//    let mut result = (*results[i]) as f64;
//    let mut color = "\e[1;32m";
//    if result > avg {
//      color = "\e[1;31m";
//    }
//    // ms or s
//    let mut unit = "ms";
//    let mut divider = 1;
//    if result >= 1000.0 {
//      unit = "s";
//      divider = 1000;
//    }
//    unsafe {
//      CLib::printf(@c_str(" \e[1m%s\e[0m: %s%f%s\e[0m\n"), name, color.bytes(), result / divider, unit.bytes());
//    }
//  }
//
//  // ms or s
//  let mut unit = "ms";
//  let mut divider = 1;
//
//  unsafe {
//    CLib::printf(@c_str("\n"));
//    if min >= 1000 {
//      unit = "s";
//      divider = 1000;
//      min = min / divider;
//    }
//    CLib::printf(@c_str(" \e[1;32mmin\e[0m: %d%s\n"), min, unit);
//    if max >= 1000 {
//      unit = "s";
//      divider = 1000;
//      max = max / divider;
//    } else unit = "ms";
//    CLib::printf(@c_str(" \e[1;31mmax\e[0m: %d%s\n"), max, unit);
//    if avg >= 1000 {
//      unit = "s";
//      divider = 1000;
//      avg = avg / divider;
//    } else unit = "ms";
//    CLib::printf(@c_str(" \e[1mavg\e[0m: %d%s\n"), avg, unit);
//  }
//}
